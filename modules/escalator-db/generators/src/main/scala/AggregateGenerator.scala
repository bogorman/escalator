package escalator.db.generators

import java.io.File
import java.io.PrintStream
import java.nio.file.Files
import java.nio.file.Paths
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet

import com.typesafe.scalalogging.Logger
import io.getquill.NamingStrategy

import escalator.util.disk._
import escalator.util._

// import db.generators._
import escalator.db.generators.AttributeTypeData

import org.scalafmt.interfaces.Scalafmt
import scala.meta._
import scala.reflect.classTag

import scala.collection.mutable.{ ArrayBuffer => MList }
import scala.collection.mutable.{ Map => MMap }

import TextUtil._

class AggregateGenerator(
    tables: List[Table],
    namingStrategy: NamingStrategy,
    options: CodegenOptions,
    customGen: CustomGenerator
) {

  def generateAggregateRoot(rootTableName: String, uniqueId: String = "id", maxDepth: Int = 3): Unit = {
    val startTime = System.currentTimeMillis()
    Class.forName(options.jdbcDriver)
    val db: Connection = DriverManager.getConnection(options.url, options.user, options.password)
    
    // Initialize auto-generated column attribute type mappings from database constraints
    val autoMappings = ConnectionUtils.getColumnAttributeTypeMappingsFromConstraints(db)
    customGen.setAutoGeneratedColumnMappings(autoMappings)
    
    try {
      println(s"Generating aggregate root for table: $rootTableName")

      // 1. Build reference tree starting from root table
      val referenceTree = ReferenceTreeBuilder.buildReferenceTree(db, rootTableName, maxDepth, options)
      println(s"Reference tree: $referenceTree")
      
      // 2. Generate aggregate state and event handler
      val aggregateName = namingStrategy.table(rootTableName)
      val baseStateCode = generateBaseAggregateState(rootTableName, referenceTree)
      val eventHandlerCode = generateAggregateEventHandler(rootTableName, referenceTree)
      val stateRepositoryCode = generateAggregateStateRepository(rootTableName, referenceTree)
      
      // 3. Write files for this aggregate
      writeAggregateFiles(aggregateName, baseStateCode, eventHandlerCode, stateRepositoryCode)

      val endTime = System.currentTimeMillis()
      println(s"Generated aggregate $aggregateName in ${endTime - startTime}ms")
      
    } finally {
      db.close()
    }
  }
  

  def mergeOnFullWord(s1: String, s2: String): String = {
    val words1 = s1.split("_")
    val words2 = s2.split("_")

    // Find the longest overlap based on full words
    val maxOverlap = (1 to words1.length).findLast { i =>
      words2.startsWith(words1.takeRight(i))
    }.getOrElse(0)

    // Merge by removing the overlapping words from s2
    val mergedWords = words1 ++ words2.drop(maxOverlap)
    mergedWords.mkString("_")
  }

  def generateFieldName(ref: ReferenceNode, allRefs: List[ReferenceNode]): String = {
    val baseColumnName = ref.foreignKeyColumn.replace("_id", "")
    val baseName = snakeToLowerCamel(baseColumnName)
    val tableName = namingStrategy.table(ref.table)
    
    // Create base field name
    val fieldName = if (baseColumnName == "id") {
      s"${tableName.toLowerCase}Ids"
    } else if (baseName.toLowerCase.contains(tableName.toLowerCase)) {
      s"${baseName}Ids"
    } else {
      s"${baseName}${tableName}Ids"
    }
    
    // Check for conflicts and disambiguate
    val conflicts = allRefs.count { otherRef =>
      val otherBaseColumnName = otherRef.foreignKeyColumn.replace("_id", "")
      val otherBaseName = snakeToLowerCamel(otherBaseColumnName)
      val otherTableName = namingStrategy.table(otherRef.table)
      val otherFieldName = if (otherBaseColumnName == "id") {
        s"${otherTableName.toLowerCase}Ids"
      } else if (otherBaseName.toLowerCase.contains(otherTableName.toLowerCase)) {
        s"${otherBaseName}Ids"
      } else {
        s"${otherBaseName}${otherTableName}Ids"
      }
      otherFieldName == fieldName
    }
    
    if (conflicts > 1) {
      // Add table name for disambiguation
      s"${baseName}${namingStrategy.table(ref.table)}Ids"
    } else {
      fieldName
    }
  }

  def generateNestedMapFieldName(parentNode: ReferenceNode, childNode: ReferenceNode, allPairs: List[ParentChildPair]): String = {
    val parentTableName = namingStrategy.table(parentNode.table).toLowerCase
    val childTableName = namingStrategy.table(childNode.table).toLowerCase
    val parentBaseColumnName = parentNode.foreignKeyColumn.replace("_id", "")
    val childBaseColumnName = childNode.foreignKeyColumn.replace("_id", "")
    val parentBaseName = snakeToLowerCamel(parentBaseColumnName)
    val childBaseName = snakeToLowerCamel(childBaseColumnName)
    
    // Create base field name
    val baseFieldName = if (parentBaseColumnName == "id") {
      s"${parentTableName}${childTableName.capitalize}"
    } else if (childBaseColumnName == "id") {
      s"${parentBaseName}${childTableName.capitalize}"
    } else {
      s"${parentBaseName}${childBaseName.capitalize}"
    }
    
    // Check for conflicts and disambiguate
    val conflicts = allPairs.count { otherPair =>
      val otherParentTableName = namingStrategy.table(otherPair.parentNode.table).toLowerCase
      val otherChildTableName = namingStrategy.table(otherPair.childNode.table).toLowerCase
      val otherParentBaseColumnName = otherPair.parentNode.foreignKeyColumn.replace("_id", "")
      val otherChildBaseColumnName = otherPair.childNode.foreignKeyColumn.replace("_id", "")
      val otherParentBaseName = snakeToLowerCamel(otherParentBaseColumnName)
      val otherChildBaseName = snakeToLowerCamel(otherChildBaseColumnName)
      
      val otherBaseFieldName = if (otherParentBaseColumnName == "id") {
        s"${otherParentTableName}${otherChildTableName.capitalize}"
      } else if (otherChildBaseColumnName == "id") {
        s"${otherParentBaseName}${otherChildTableName.capitalize}"
      } else {
        s"${otherParentBaseName}${otherChildBaseName.capitalize}"
      }
      otherBaseFieldName == baseFieldName
    }
    
    if (conflicts > 1) {
      // Add more specificity for disambiguation
      s"${parentTableName}${parentBaseName.capitalize}${childTableName.capitalize}${childBaseName.capitalize}"
    } else {
      baseFieldName
    }
  }

  def generateBaseAggregateState(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    
    // Direct children (store as List[EntityId])
    val directRefs = tree.nodes.filter(node => node.depth == 0)
    val directIdFields = directRefs.map { ref =>
      val fieldName = generateFieldName(ref, directRefs)
      s"  $fieldName: List[${namingStrategy.table(singularize(ref.table))}Id] = List.empty"
    }
    
    // Nested Maps for children of children (e.g., postComments: Map[PostId, List[CommentId]])
    // First collect all parent-child pairs for unique naming
    val nestedPairs = tree.nodes.flatMap { parentNode =>
      if (!parentNode.isWeakReference) {
        parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
          ParentChildPair(parentNode, childNode)
        }
      } else {
        List.empty
      }
    }
    
    val nestedMaps = nestedPairs.map { pair =>
      // Use the actual foreign key type based on what the child references
      val parentKeyType = resolveForeignKeyType(pair.childNode)
      val childId = s"${namingStrategy.table(singularize(pair.childNode.table))}Id"
      val fieldName = generateNestedMapFieldName(pair.parentNode, pair.childNode, nestedPairs)
      s"  $fieldName: Map[$parentKeyType, List[$childId]] = Map.empty"
    }
    
    val allFields = directIdFields ++ nestedMaps
    val fieldsString = {
      val metadataComment = ",\n  \n  // Event sourcing metadata"
      if (allFields.nonEmpty) {
        val childrenSection = ",\n  \n  // Direct children\n" + allFields.mkString(",\n")
        childrenSection + metadataComment
      } else {
        metadataComment
      }
    }
    
    s"""package ${options.packageName}.core.actors.state.${rootEntityFieldName}

${GeneratorTemplates.autoGeneratedComment}

//import scala.concurrent.Future
//import monix.eval.Task
import escalator.ddd.Event
import escalator.models.CorrelationId
import escalator.util.Timestamp
import ${options.packageName}.models._
// import ${options.packageName}.models.events._

/**
 * Base aggregate state for ${aggregateName}
 * Contains the root entity plus IDs of all related entities
 */
case class Base${aggregateName}State(
  ${rootEntityFieldName}: Option[${aggregateName}] = None${fieldsString}
  version: Long = 0L,
  lastUpdated: Timestamp = Timestamp(0L)
) {
  /**
   * Apply an event to update the aggregate state
   */
  def applyEvent(event: Event): Base${aggregateName}State = event match {
    case e: events.${aggregateName}Event => ${aggregateName}EventHandler.apply(this, e)${generateEventMatchCases(tree, aggregateName)}
    case _ => this  // Ignore unrelated events
  }
}

object Base${aggregateName}State {
  def empty(${rootEntityFieldName}Id: ${aggregateName}Id): Base${aggregateName}State = {
    Base${aggregateName}State(
      ${rootEntityFieldName} = None,
      version = 0L,
      lastUpdated = Timestamp(0L)
    )
  }
}
"""
  }
  
  def generateEventMatchCases(tree: ReferenceTree, aggregateName: String): String = {
    // Deduplicate by table name to avoid duplicate event cases
    val uniqueTables = tree.nodes.filter(node => !node.isWeakReference).map(_.table).distinct
    val eventCases = uniqueTables.map { table =>
      val eventName = namingStrategy.table(singularize(table))
      s"""
    case e: events.${eventName}Event => ${aggregateName}EventHandler.apply(this, e)"""
    }
    eventCases.mkString
  }
  
  def generateAggregateEventHandler(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    
    // Generate handler methods for each event type
    val rootEventHandler = generateRootEventHandler(rootTableName, aggregateName)
    // Deduplicate by table name to avoid duplicate handlers for the same entity type
    val uniqueChildTables = tree.nodes.filter(node => !node.isWeakReference).map(_.table).distinct
    val childEventHandlers = uniqueChildTables.map { tableName =>
      // Find a representative node for this table
      val representativeNode = tree.nodes.find(_.table == tableName).get
      generateChildEventHandler(rootTableName, representativeNode, tree, aggregateName)
    }.mkString("\n")
    
    s"""package ${options.packageName}.core.actors.state.${rootEntityFieldName}

${GeneratorTemplates.autoGeneratedComment}

import escalator.ddd.Event
import escalator.models.CorrelationId
import escalator.util.Timestamp
import ${options.packageName}.models._
// import ${options.packageName}.models.events._

/**
 * Pure event handlers for ${aggregateName} aggregate
 * These are side-effect free functions for applying events to state
 */
object ${aggregateName}EventHandler {
  
$rootEventHandler
  
$childEventHandlers
}
"""
  }
  
  def generateRootEventHandler(rootTableName: String, aggregateName: String): String = {
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    s"""  /**
   * Handle events for the root ${aggregateName} entity
   */
  def apply(state: Base${aggregateName}State, event: events.${aggregateName}Event): Base${aggregateName}State = {
    event match {
      case events.${aggregateName}Created($rootEntityFieldName, _, correlationId, timestamp) =>
        state.copy(
          $rootEntityFieldName = Some($rootEntityFieldName),
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case events.${aggregateName}Updated($rootEntityFieldName, previous${aggregateName}, _, correlationId, timestamp) =>
        state.copy(
          $rootEntityFieldName = Some($rootEntityFieldName),
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case events.${aggregateName}Deleted($rootEntityFieldName, _, correlationId, timestamp) =>
        // Mark as deleted by setting to None
        state.copy(
          $rootEntityFieldName = None,
          version = state.version + 1,
          lastUpdated = timestamp
        )
    }
  }"""
  }
  
  def generateChildEventHandler(rootTableName: String, node: ReferenceNode, tree: ReferenceTree, aggregateName: String): String = {
    val childName = namingStrategy.table(singularize(node.table))
    val childNameLower = node.table.toLowerCase
    val foreignKeyCheck = generateForeignKeyCheck(node, rootTableName)
    val nestedUpdates = generateNestedUpdates(node, tree)
    val depthDescription = if (node.depth == 0) "direct children" else s"depth ${node.depth}"
    
    // Use consistent field naming for direct children
    val directRefs = tree.nodes.filter(n => n.depth == 0 && !n.isWeakReference)
    val fieldName = generateFieldName(node, directRefs)
    
    s"""  /**
   * Handle events for ${childName} entities ($depthDescription)
   */
  def apply(state: Base${aggregateName}State, event: events.${childName}Event): Base${aggregateName}State = {
    event match {
      case events.${childName}Created(${childNameLower}, _, correlationId, timestamp) if $foreignKeyCheck =>
        state.copy(
          $fieldName = state.$fieldName :+ ${childNameLower}.id,
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case events.${childName}Updated(${childNameLower}, previous${childName}, _, correlationId, timestamp) if $foreignKeyCheck =>
        // No ID changes needed for updates
        state.copy(
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case events.${childName}Deleted(${childNameLower}, _, correlationId, timestamp) if $foreignKeyCheck =>
        state.copy(
          $fieldName = state.$fieldName.filterNot(_ == ${childNameLower}.id),$nestedUpdates
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case _ => state  // Event not relevant to this aggregate
    }
  }"""
  }
  
  def generateForeignKeyCheck(node: ReferenceNode, rootTableName: String): String = {
    if (node.depth == 0) {
      // Direct child - check against root entity ID (now Optional)
      val rootEntityFieldName = singularize(rootTableName.toLowerCase)
      // Convert database column name (user_id) to Scala property name (userId)
      val scalaPropertyName = namingStrategy.column(node.foreignKeyColumn)
      s"state.$rootEntityFieldName.exists(_.id == ${node.table.toLowerCase}.$scalaPropertyName)"
    } else {
      // Nested child - check if parent is in our collection
      val parentTable = findParentTable(node, rootTableName)
      val parentIdField = TextUtil.snakeToLowerCamel(parentTable) + "Ids"  // parentTable is already plural
      // Convert database column name to Scala property name
      val scalaPropertyName = namingStrategy.column(node.foreignKeyColumn)
      s"state.$parentIdField.contains(${node.table.toLowerCase}.$scalaPropertyName)"
    }
  }
  
  def generateNestedUpdates(node: ReferenceNode, tree: ReferenceTree): String = {
    if (node.children.nonEmpty) {
      // Generate all nested pairs for consistent naming
      val nestedPairs = tree.nodes.flatMap { parentNode =>
        if (!parentNode.isWeakReference) {
          parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
            ParentChildPair(parentNode, childNode)
          }
        } else {
          List.empty
        }
      }

      val childCleanups = node.children.filter(!_.isWeakReference).map { child =>
        val mapField = generateNestedMapFieldName(node, child, nestedPairs)
        // Determine which field to access based on what the child's foreign key references
        val parentFieldAccessor = child.referencedColumn.map(col => namingStrategy.column(col)).getOrElse("id")
        s"$mapField = state.$mapField - ${node.table.toLowerCase}.$parentFieldAccessor"
      }
      "\n          " + childCleanups.mkString(",\n          ") + ","
    } else {
      ""
    }
  }
  
  def findParentTable(node: ReferenceNode, rootTableName: String): String = {
    // This is a simplified approach - in a full implementation,
    // you'd need to traverse the tree to find the actual parent
    rootTableName
  }
  
  def generateAggregateStateRepository(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)

    // Generate loading logic for each level
    // val loadingLogic = generateStateLoadingLogic(rootTableName, tree, aggregateName)
    val loadingLogic = s"""
          Task.pure(Some(Base${aggregateName}State.empty(userId)))
    """

    s"""package ${options.packageName}.core.actors.state.${rootEntityFieldName}

${GeneratorTemplates.autoGeneratedComment}

import scala.concurrent.{ExecutionContext, Future}
import escalator.util.logging.Logger
import escalator.ddd.Event
import escalator.models.CorrelationId
import escalator.util.{Timestamp, TimeUtil}
import ${options.packageName}.models._
// import ${options.packageName}.models.events._
import ${options.packageName}.core.repositories.${options.appName}Repository

import monix.eval.Task
import escalator.util.monix.TaskSyntax._


/**
 * Repository for loading and managing ${aggregateName} aggregate state
 * Supports both DB bootstrapping and event replay
 */
object ${aggregateName}StateRepository {

  /**
   * Load complete aggregate state from database
   */
  def load${aggregateName}State(
    repo: ${options.appName}Repository,
    ${rootEntityFieldName}Id: ${aggregateName}Id
  )(implicit ec: ExecutionContext, logger: Logger): Task[Option[Base${aggregateName}State]] = {
$loadingLogic
  }

  /**
   * Load multiple states efficiently
   */
  def load${aggregateName}States(
    repo: ${options.appName}Repository,
    ids: List[${aggregateName}Id]
  )(implicit ec: ExecutionContext, logger: Logger): Task[Map[${aggregateName}Id, Base${aggregateName}State]] = {
    Task.sequence(ids.map { id =>
      load${aggregateName}State(repo, id).map(stateOpt => id -> stateOpt)
    }).map(_.collect { case (id, Some(state)) => id -> state }.toMap)
  }

  /**
   * Replay events to rebuild state (Pekko Persistence compatible)
   */
  def replay${aggregateName}State(
    ${rootEntityFieldName}Id: ${aggregateName}Id,
    fromSequenceNr: Long = 0L
  )(implicit ec: ExecutionContext, logger: Logger): Task[Base${aggregateName}State] = {
    // This method would integrate with your event store
    // For now, return empty state as placeholder
    Task.pure(Base${aggregateName}State.empty(${rootEntityFieldName}Id))
  }

  /**
   * Apply events to state in sequence
   */
  def applyEvents(initialState: Base${aggregateName}State, events: List[Event]): Base${aggregateName}State = {
    events.foldLeft(initialState)(_.applyEvent(_))
  }
}
"""
  }
  
  def generateStateLoadingLogic(rootTableName: String, tree: ReferenceTree, aggregateName: String): String = {
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    s"""    for {
      // Load root entity
      ${rootEntityFieldName}Opt <- Task.fromFuture(repo.${TextUtil.snakeToLowerCamel(rootTableName)}.getById(${rootEntityFieldName}Id))

      state <- ${rootEntityFieldName}Opt match {
        case None => Task.pure(None)
        case Some(${rootEntityFieldName}) =>
          for {
${generateDirectChildrenLoading(tree)}
${generateNestedChildrenLoading(tree)}

          } yield Some(Base${aggregateName}State(
            ${rootEntityFieldName} = Some(${rootEntityFieldName}),
${generateStateConstruction(tree)}
            version = 0L,
            lastUpdated = TimeUtil.nowTimestamp()
          ))
      }
    } yield state"""
  }
  
  def generateDirectChildrenLoading(tree: ReferenceTree): String = {
    val directChildren = tree.nodes.filter(node => node.depth == 0 && !node.isWeakReference)
    if (directChildren.nonEmpty) {
      val loadingTasks = directChildren.map { node =>
        // node.table is already plural, don't pluralize again
        val tableName = node.table
        val foreignKeyMethodName = s"getListBy${namingStrategy.table(node.foreignKeyColumn).capitalize}"
        s"Task.fromFuture(repo.${TextUtil.snakeToLowerCamel(tableName)}.${foreignKeyMethodName}(${singularize(tree.rootTable.toLowerCase)}Id))"
      }
      
      if (directChildren.size == 1) {
        // Single task - no need for parMap
        val varName = generateFieldName(directChildren.head, directChildren).replace("Ids", "s")
        s"""            // Load direct children
            $varName <- ${loadingTasks.head}"""
      } else {
        // Multiple tasks - use parMapN (up to 10) or parSequence
        val taskCount = directChildren.size
        if (taskCount >= 2 && taskCount <= 10) {
          val paramNames = directChildren.zipWithIndex.map { case (_, i) => s"p$i" }
          val combiningFunction = s"((${paramNames.mkString(", ")}) => (${paramNames.mkString(", ")}))"
          val varNames = directChildren.map(node => generateFieldName(node, directChildren).replace("Ids", "s")).mkString(", ")
          s"""            // Load direct children in parallel
            ($varNames) <- Task.parMap$taskCount(
              ${loadingTasks.mkString(",\n              ")}
            )$combiningFunction"""
        } else {
          // For large numbers of tasks, assign each variable individually with explicit types
          val loadingCode = s"""            // Load direct children in parallel - many children (${taskCount})
            allChildren <- Task.parSequence(List(
              ${loadingTasks.mkString(",\n              ")}
            ))"""
          
          val assignmentCode = directChildren.zipWithIndex.map { case (node, i) =>
            val varName = generateFieldName(node, directChildren).replace("Ids", "s")
            val modelName = namingStrategy.table(singularize(node.table)) // Convert plural table to singular model
            s"            $varName = allChildren($i).asInstanceOf[List[$modelName]]"
          }.mkString("\n")
          
          s"""$loadingCode
$assignmentCode"""
        }
      }
    } else {
      "            // No direct children to load"
    }
  }
  
  def resolveForeignKeyType(node: ReferenceNode): String = {
    // Use the actual referenced table and column from the foreign key constraint
    (node.referencedTable, node.referencedColumn) match {
      case (Some(refTable), Some(refColumn)) =>
        // Generate type name based on referenced table and column
        val tableTypeName = namingStrategy.table(singularize(refTable))
        val columnSuffix = refColumn match {
          case "id" => "Id"
          case col => namingStrategy.table(col.split("_").map(_.capitalize).mkString)
        }
        s"$tableTypeName$columnSuffix"

      case _ =>
        // Fallback to old behavior if referenced metadata is not available
        val columnBase = node.foreignKeyColumn.replace("_id", "")
        columnBase match {
          case "ref_message" | "post" => "MessageId"
          case _ => s"${namingStrategy.table(singularize(columnBase))}Id"
        }
    }
  }

  def generateNestedChildrenLoading(tree: ReferenceTree): String = {
    val nestedNodes = tree.nodes.filter(node => node.children.nonEmpty)
    if (nestedNodes.nonEmpty) {
      // Generate all nested pairs for consistent naming
      val nestedPairs = tree.nodes.flatMap { parentNode =>
        if (!parentNode.isWeakReference) {
          parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
            ParentChildPair(parentNode, childNode)
          }
        } else {
          List.empty
        }
      }
      
      val loadingLogic = nestedPairs.map { pair =>
        val parentNode = pair.parentNode
        val childNode = pair.childNode
        // Both parentNode.table and childNode.table are already plural
        val parentRefs = tree.nodes.filter(node => node.depth == 0 && !node.isWeakReference)
        val parentVarName = generateFieldName(parentNode, parentRefs).replace("Ids", "s")
        val mapVarName = s"${TextUtil.snakeToLowerCamel(singularize(parentNode.table))}${TextUtil.snakeToUpperCamel(childNode.foreignKeyColumn.replace("_id", ""))}${namingStrategy.table(childNode.table)}Map"
        val foreignKeyType = resolveForeignKeyType(childNode)

        // Determine which field to access on the parent object (e.g., .id or .token)
        val parentFieldAccessor = childNode.referencedColumn.map(col => namingStrategy.column(col)).getOrElse("id")

        s"""            // Load ${childNode.table} for each ${parentNode.table}
            $mapVarName <- if ($parentVarName.nonEmpty) {
              Task.fromFuture(repo.${TextUtil.snakeToLowerCamel(childNode.table)}.getListBy${namingStrategy.table(childNode.foreignKeyColumn).capitalize}s($parentVarName.map(_.$parentFieldAccessor)))
                .map(_.groupBy(_.${namingStrategy.column(childNode.foreignKeyColumn)}).map { case (k, v) => k -> v.map(_.id) }.asInstanceOf[Map[$foreignKeyType, List[${namingStrategy.table(singularize(childNode.table))}Id]]])
            } else {
              Task.pure(Map.empty[$foreignKeyType, List[${namingStrategy.table(singularize(childNode.table))}Id]])
            }"""
      }.mkString("\n")
      
      s"""            // Load nested children
$loadingLogic"""
    } else {
      ""
    }
  }
  
  def generateStateConstruction(tree: ReferenceTree): String = {
    val directRefs = tree.nodes.filter(node => node.depth == 0 && !node.isWeakReference)
    val directChildIds = directRefs.map { node =>
      val fieldName = generateFieldName(node, directRefs)
      val varName = fieldName.replace("Ids", "s")
      s"            $fieldName = $varName.map(_.id),"
    }
    
    // Generate nested maps with consistent naming
    val nestedPairs = tree.nodes.flatMap { parentNode =>
      if (!parentNode.isWeakReference) {
        parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
          ParentChildPair(parentNode, childNode)
        }
      } else {
        List.empty
      }
    }
    
    val nestedMaps = nestedPairs.map { pair =>
      val fieldName = generateNestedMapFieldName(pair.parentNode, pair.childNode, nestedPairs)
      val varName = s"${TextUtil.snakeToLowerCamel(singularize(pair.parentNode.table))}${TextUtil.snakeToUpperCamel(pair.childNode.foreignKeyColumn.replace("_id", ""))}${namingStrategy.table(pair.childNode.table)}Map"
      s"            $fieldName = $varName,"
    }
    
    (directChildIds ++ nestedMaps).mkString("\n")
  }
  
  def writeAggregateFiles(aggregateName: String, baseStateCode: String, eventHandlerCode: String, stateRepositoryCode: String): Unit = {
    // State files always go to core/actors/state
    val stateFolder = if (options.repositoriesFolder.nonEmpty) {
      options.repositoriesFolder.replaceAll("/repositories/postgres$", s"/actors/state/${aggregateName.toLowerCase}")
    } else {
      s"${options.persistenceBaseFolder}/core/actors/state/${aggregateName.toLowerCase}"
    }

    FileUtil.createDirectoriesForFolder(stateFolder)

    // Write state files to core/actors/state
    writeIfDoesNotExist(s"$stateFolder/Base${aggregateName}State.scala", formatCode(baseStateCode))
    writeIfDoesNotExist(s"$stateFolder/${aggregateName}EventHandler.scala", formatCode(eventHandlerCode))
    writeIfDoesNotExist(s"$stateFolder/${aggregateName}StateRepository.scala", formatCode(stateRepositoryCode))

    // Codecs generation disabled - BaseUserState is too complex for auto-derivation
    // Users should implement serialization manually if needed
    // val codecsCode = generateCodecsTemplate(aggregateName)
    // FileUtil.write(s"$stateFolder/Base${aggregateName}StateCodecs.scala", formatCode(codecsCode))

    // Write custom extension files to core/actors/state
    val customStateCode = generateCustomStateTemplate(aggregateName)
    writeIfDoesNotExist(s"$stateFolder/${aggregateName}State.scala", formatCode(customStateCode))

    val customLogicCode = generateCustomLogicTemplate(aggregateName)
    writeIfDoesNotExist(s"$stateFolder/${aggregateName}BusinessLogic.scala", formatCode(customLogicCode))
  }
  
  def generateCustomStateTemplate(aggregateName: String): String = {
    s"""package ${options.packageName}.core.actors.state.${aggregateName.toLowerCase}

// This file is never overwritten by the generator
// Add your custom state extensions and business logic here

import ${options.packageName}.core.actors.state.${aggregateName.toLowerCase}.Base${aggregateName}State
import ${options.packageName}.models._

/**
 * Extended ${aggregateName} state with custom business logic
 * Extend Base${aggregateName}State and add your domain-specific methods
 */
case class ${aggregateName}State(base: Base${aggregateName}State) {

  // Delegate to base state
  def ${aggregateName.toLowerCase} = base.${aggregateName.toLowerCase}
  def version = base.version
  def lastUpdated = base.lastUpdated

  // Add your custom computed properties here
  // Example:
  // def totalPosts: Int = base.postsIds.size
  // def isActive: Boolean = base.user.status == "active"

  // Add your custom business logic methods here
  // Example:
  // def canCreatePost: Boolean = isActive && totalPosts < 100
}

object ${aggregateName}State {
  def fromBase(baseState: Base${aggregateName}State): ${aggregateName}State =
    ${aggregateName}State(baseState)
}
"""
  }
  
  def generateCustomLogicTemplate(aggregateName: String): String = {
    s"""package ${options.packageName}.core.actors.state.${aggregateName.toLowerCase}

// This file is never overwritten by the generator
// Add your custom business logic and domain services here

import scala.concurrent.Future
import monix.eval.Task
import escalator.ddd.Event
import ${options.packageName}.core.actors.state.${aggregateName.toLowerCase}.Base${aggregateName}State
import ${options.packageName}.models._
// import ${options.packageName}.models.events._

/**
 * Business logic for ${aggregateName} aggregate
 * Add your domain-specific operations here
 */
class ${aggregateName}BusinessLogic {

  /**
   * Example business rule validation
   */
  def validate${aggregateName}Creation(data: ${aggregateName}): Task[Either[String, ${aggregateName}]] = {
    // Add your validation logic here
    Task.pure(Right(data))
  }

  /**
   * Example business operation
   */
  def process${aggregateName}Command(state: Base${aggregateName}State, command: Any): Task[List[Event]] = {
    // Add your command processing logic here
    Task.pure(List.empty)
  }

  // Add more business logic methods as needed
}

object ${aggregateName}BusinessLogic {
  def apply(): ${aggregateName}BusinessLogic = new ${aggregateName}BusinessLogic()
}
"""
  }

  def generateCodecsTemplate(aggregateName: String): String = {
    s"""package ${options.packageName}.core.actors.state.${aggregateName.toLowerCase}

${GeneratorTemplates.autoGeneratedComment}

import io.circe._
import io.circe.generic.semiauto._
import ${options.packageName}.models._

/**
 * JSON Codecs for ${aggregateName} State
 * Auto-generated Circe encoders/decoders for serialization
 */
object Base${aggregateName}StateCodecs {

  implicit val base${aggregateName}StateEncoder: Encoder[Base${aggregateName}State] = deriveEncoder[Base${aggregateName}State]
  implicit val base${aggregateName}StateDecoder: Decoder[Base${aggregateName}State] = deriveDecoder[Base${aggregateName}State]

}
"""
  }

  def writeAggregateActor(aggregateName: String, actorBaseTrait: String, actorPlaceholder: String): Unit = {
    val actorsFolder = if (options.aggregatesFolder.nonEmpty) {
      s"${options.aggregatesFolder}/actors"
    } else {
      s"${options.persistenceBaseFolder}/aggregates/actors"
    }

    FileUtil.createDirectoriesForFolder(actorsFolder)

    // Always overwrite the base trait (auto-generated)
    FileUtil.write(s"$actorsFolder/${aggregateName}ActorBase.scala", formatCode(actorBaseTrait))

    // Only create placeholder if doesn't exist (user-editable)
    writeIfDoesNotExist(s"$actorsFolder/${aggregateName}Actor.scala", formatCode(actorPlaceholder))
  }
  
  def generateUserActorBaseTrait(db: Connection, rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)

    val extractionCases = generateEventExtractionCases(db, tree, rootTableName, aggregateName, rootEntityFieldName)

    s"""package ${options.packageName}.aggregates.actors

${GeneratorTemplates.autoGeneratedComment}

import scala.concurrent.{ExecutionContext, Future}
import scala.util.{Success, Failure}
import org.apache.pekko.actor.{Actor, ActorLogging, ActorRef}
import monix.execution.Scheduler
import escalator.ddd.Event
import escalator.util.logging.Logger
import ${options.packageName}.models._
import ${options.packageName}.models.events._
import ${options.packageName}.aggregates.${rootEntityFieldName}.{Base${aggregateName}State, ${aggregateName}StateRepository}
import ${options.packageName}.cache.distributed.DistributedCacheManager

/**
 * Auto-generated base trait for ${aggregateName} actor
 * Contains all boilerplate logic - DO NOT EDIT
 *
 * This trait is regenerated on every 'sbt dbGenerate'
 * Custom logic goes in ${aggregateName}Actor class
 */
trait ${aggregateName}ActorBase extends Actor with ActorLogging {

  // Abstract members - provided by concrete class
  def ${rootEntityFieldName}Id: ${aggregateName}Id
  def stateRepository: ${aggregateName}StateRepository
  def distributedCacheManager: DistributedCacheManager
  implicit def ec: ExecutionContext
  implicit def scheduler: Scheduler
  implicit def logger: Logger

  // State management
  protected var state: Base${aggregateName}State = Base${aggregateName}State.empty(${rootEntityFieldName}Id)
  protected var loaded: Boolean = false
  protected var clientConnection: Option[ActorRef] = None

  override def preStart(): Unit = {
    super.preStart()
    log.info(s"${aggregateName}Actor starting for ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}")
    loadStateFromCache()
  }

  override def postStop(): Unit = {
    log.info(s"${aggregateName}Actor stopping for ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}")
    saveStateToCache()
    super.postStop()
  }

  /**
   * Default message handling - can be used by concrete class
   */
  def baseReceive: Receive = {
    case ${aggregateName}Actor.${aggregateName}EventMessage(event) =>
      handleEvent(event)

    case ${aggregateName}Actor.Get${aggregateName}State(replyTo) =>
      replyTo ! ${aggregateName}Actor.${aggregateName}StateResponse(state)

    case ${aggregateName}Actor.RegisterClient(clientRef) =>
      registerClient(clientRef)

    case ${aggregateName}Actor.UnregisterClient =>
      unregisterClient()

    case ${aggregateName}Actor.StopUser =>
      context.stop(self)
  }

  /**
   * Register WebSocket client for real-time updates
   */
  protected def registerClient(clientRef: ActorRef): Unit = {
    clientConnection = Some(clientRef)
    log.info(s"Client registered for ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}")
    // Send current state to newly connected client
    pushStateUpdate()
  }

  /**
   * Unregister WebSocket client
   */
  protected def unregisterClient(): Unit = {
    clientConnection = None
    log.info(s"Client unregistered for ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}")
  }

  /**
   * Push state update to connected WebSocket client
   */
  protected def pushStateUpdate(): Unit = {
    clientConnection.foreach { client =>
      client ! ${aggregateName}Actor.PushStateUpdate(state)
    }
  }

  /**
   * Cache-first state loading - tries cache first, falls back to database
   */
  protected def loadStateFromCache(): Unit = {
    if (loaded) return

    distributedCacheManager.get${aggregateName}State(${rootEntityFieldName}Id).onComplete {
      case Success(Some(cachedState)) =>
        state = cachedState
        loaded = true
        log.info(s"Loaded ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} from cache (version: $${cachedState.version})")

      case Success(None) =>
        log.debug(s"Cache miss for ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}, loading from database")
        stateRepository.load${aggregateName}State(${rootEntityFieldName}Id).runToFuture.onComplete {
          case Success(Some(dbState)) =>
            state = dbState
            loaded = true
            log.info(s"Loaded ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} from database (version: $${dbState.version})")
            // Warm cache for next time
            distributedCacheManager.save${aggregateName}State(${rootEntityFieldName}Id, dbState)

          case Success(None) =>
            log.warning(s"${aggregateName} $${${rootEntityFieldName}Id.id} not found in database")
            loaded = true

          case Failure(ex) =>
            log.error(ex, s"Failed to load ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} from database")
        }

      case Failure(ex) =>
        log.error(ex, s"Cache error for ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}, falling back to database")
        // Fallback to database loading (same logic as cache miss)
        stateRepository.load${aggregateName}State(${rootEntityFieldName}Id).runToFuture.onComplete {
          case Success(Some(dbState)) =>
            state = dbState
            loaded = true
            log.info(s"Loaded ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} from database after cache error")

          case Success(None) =>
            log.warning(s"${aggregateName} $${${rootEntityFieldName}Id.id} not found in database")
            loaded = true

          case Failure(dbEx) =>
            log.error(dbEx, s"Failed to load ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} from database after cache error")
        }
    }
  }

  /**
   * Save state to cache on actor shutdown
   */
  protected def saveStateToCache(): Unit = {
    if (!loaded) {
      log.debug(s"${aggregateName} $${${rootEntityFieldName}Id.id} was never loaded, skipping cache save")
      return
    }

    log.info(s"Saving ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} state (version: $${state.version}) to cache")
    distributedCacheManager.save${aggregateName}State(${rootEntityFieldName}Id, state).onComplete {
      case Success(_) =>
        log.info(s"Successfully saved ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} to cache")
      case Failure(ex) =>
        log.error(ex, s"Failed to save ${rootEntityFieldName} $${${rootEntityFieldName}Id.id} to cache")
    }
  }

  /**
   * Handle event - apply to state using generated event handler
   */
  protected def handleEvent(event: Event): Unit = {
    log.debug(s"${aggregateName} $${${rootEntityFieldName}Id.id} received event: $${event.getClass.getSimpleName}")

    // Apply event using generated applyEvent method
    state = state.applyEvent(event)

    log.debug(s"Applied event to ${rootEntityFieldName} $${${rootEntityFieldName}Id.id}, version now: $${state.version}")

    // Push state update to connected WebSocket client
    pushStateUpdate()
  }
}

/**
 * Companion object for ${aggregateName}ActorBase
 * Contains auto-generated extraction logic for routing events to correct actor instances
 */
object ${aggregateName}ActorBase {

  /**
   * Extract ${rootEntityFieldName}Id from event
   * Auto-generated based on aggregate reference tree
   *
   * This method is regenerated every time dbGenerate runs, ensuring it stays
   * up-to-date with schema changes (new tables, nullable column changes, etc.)
   */
  def extract${aggregateName}Id(event: Event): Option[${aggregateName}Id] = {
    import ${options.packageName}.models.events._

    event match {
${extractionCases}

      case _ => None // Event not related to ${aggregateName} aggregate
    }
  }
}
"""
  }

  /**
   * Generate event extraction match cases from reference tree
   * Queries the database to determine if foreign key fields are nullable
   */
  def generateEventExtractionCases(db: Connection, tree: ReferenceTree, rootTableName: String, aggregateName: String, rootEntityFieldName: String): String = {
    import java.sql.DatabaseMetaData

    // Helper to check if a column is nullable
    def isColumnNullable(tableName: String, columnName: String): Boolean = {
      val cols = db.getMetaData.getColumns(null, options.schema, tableName, columnName)
      if (cols.next()) {
        cols.getBoolean("IS_NULLABLE")
      } else {
        false // Default to not nullable if we can't find the column
      }
    }

    // Root entity events - always wrapped in Some since id is never null
    val rootCase = s"""      // Root ${rootEntityFieldName} events
      case e: ${aggregateName}Event =>
        e match {
          case ${aggregateName}Created(entity, _, _, _) => Some(entity.id)
          case ${aggregateName}Updated(entity, _, _, _, _) => Some(entity.id)
          case ${aggregateName}Deleted(entity, _, _, _) => Some(entity.id)
        }"""

    // Child entity events - extract from their foreign key field
    // Group nodes by table to handle tables with multiple FKs to users
    val nodesByTable = tree.nodes.filter(_.depth == 0).groupBy(_.table)

    val childCases = nodesByTable.map { case (childTable, nodes) =>
      val childEventName = namingStrategy.table(singularize(childTable))

      // If multiple FKs to users, pick the primary one:
      // 1. Prefer non-nullable FKs (owner/creator is usually required)
      // 2. Prefer FK named "user_id" (conventional primary owner)
      // 3. Fall back to first one
      val primaryNode = if (nodes.size > 1) {
        nodes
          .sortBy { node =>
            val isNullable = isColumnNullable(node.table, node.foreignKeyColumn)
            val isUserId = node.foreignKeyColumn == "user_id"
            // Lower score = higher priority
            (if (isNullable) 1 else 0, if (isUserId) 0 else 1)
          }
          .head
      } else {
        nodes.head
      }

      val fkColumnName = primaryNode.foreignKeyColumn
      val fkFieldName = namingStrategy.column(fkColumnName)
      val isNullable = isColumnNullable(childTable, fkColumnName)

      // If nullable, field is already Option[UserId], so we don't wrap in Some
      // If not nullable, field is UserId, so we wrap in Some
      val extractionExpr = if (isNullable) {
        s"entity.${fkFieldName}"  // Already Option[UserId]
      } else {
        s"Some(entity.${fkFieldName})"  // UserId -> Option[UserId]
      }

      val otherFKsComment = if (nodes.size > 1) {
        val otherFKs = nodes.filter(_ != primaryNode).map(_.foreignKeyColumn).mkString(", ")
        s" (primary FK; table also has: ${otherFKs})"
      } else {
        ""
      }

      s"""
      // ${childTable} events - extract from ${fkFieldName} field (nullable: ${isNullable})${otherFKsComment}
      case e: ${childEventName}Event =>
        e match {
          case ${childEventName}Created(entity, _, _, _) => ${extractionExpr}
          case ${childEventName}Updated(entity, _, _, _, _) => ${extractionExpr}
          case ${childEventName}Deleted(entity, _, _, _) => ${extractionExpr}
        }"""
    }.mkString("\n")

    rootCase + childCases
  }

  def generateUserActorPlaceholder(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)

    s"""package ${options.packageName}.aggregates.actors

// THIS FILE IS SAFE TO EDIT - IT WILL NOT BE REGENERATED

import scala.concurrent.ExecutionContext
import org.apache.pekko.actor.{ActorRef, Props}
import monix.execution.Scheduler
import escalator.ddd.Event
import escalator.util.logging.Logger
import ${options.packageName}.models._
import ${options.packageName}.aggregates.${rootEntityFieldName}.{Base${aggregateName}State, ${aggregateName}StateRepository}
import ${options.packageName}.cache.distributed.DistributedCacheManager

/**
 * ${aggregateName} Actor - manages state for a single ${rootEntityFieldName} via cluster sharding
 *
 * Extends ${aggregateName}ActorBase (auto-generated) with custom business logic
 */
class ${aggregateName}Actor(
  val ${rootEntityFieldName}Id: ${aggregateName}Id,
  val stateRepository: ${aggregateName}StateRepository,
  val distributedCacheManager: DistributedCacheManager
)(implicit
  val ec: ExecutionContext,
  val scheduler: Scheduler,
  val logger: Logger
) extends ${aggregateName}ActorBase {

  // Default: use generated message handling
  override def receive: Receive = baseReceive

  // --- Custom Logic Below ---
  // Add custom message handlers and business logic here

  // Example: override receive to add custom messages
  // override def receive: Receive = customReceive.orElse(baseReceive)
  //
  // def customReceive: Receive = {
  //   case CustomMessage(data) => handleCustomMessage(data)
  // }
  //
  // private def handleCustomMessage(data: String): Unit = {
  //   // Custom business logic using state
  // }
}

object ${aggregateName}Actor {

  // Message protocol
  case class ${aggregateName}EventMessage(event: Event)
  case class Get${aggregateName}State(replyTo: ActorRef)
  case class ${aggregateName}StateResponse(state: Base${aggregateName}State)

  // WebSocket client management
  case class RegisterClient(clientRef: ActorRef)
  case object UnregisterClient
  case class PushStateUpdate(state: Base${aggregateName}State)
  case object Stop${aggregateName}

  /**
   * Props factory for creating ${aggregateName}Actor instances
   */
  def props(
    ${rootEntityFieldName}Id: ${aggregateName}Id,
    stateRepository: ${aggregateName}StateRepository,
    distributedCacheManager: DistributedCacheManager
  )(implicit
    ec: ExecutionContext,
    scheduler: Scheduler,
    logger: Logger
  ): Props = Props(new ${aggregateName}Actor(${rootEntityFieldName}Id, stateRepository, distributedCacheManager))
}
"""
  }


  def applyFixes(fileData: String) = {
    // TODO: fix multi key foreign key
    customGen.processFileData(fileData)
  }

  def writeIfDoesNotExist(filePath: String, fileData: String) = {
    val fixedContent = applyFixes(fileData)

    // Add checksum to track if user modifies this file
    val file = new java.io.File(filePath)
    if (!file.exists()) {
      val contentWithChecksum = ChecksumUtil.addChecksum(fixedContent)
      FileUtil.write(filePath, contentWithChecksum)
    }
  }

  def formatCode(code: String) = {
    Formatter.format(code)
    // code
  }

}
