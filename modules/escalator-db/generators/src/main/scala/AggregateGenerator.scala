package escalator.db.generators

import java.io.File
import java.io.PrintStream
import java.nio.file.Files
import java.nio.file.Paths
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet

import com.typesafe.scalalogging.Logger
import io.getquill.NamingStrategy

import escalator.util.disk._
import escalator.util._

// import db.generators._
import escalator.db.generators.AttributeTypeData

import org.scalafmt.interfaces.Scalafmt
import scala.meta._
import scala.reflect.classTag

import scala.collection.mutable.{ ArrayBuffer => MList }
import scala.collection.mutable.{ Map => MMap }

import TextUtil._

class AggregateGenerator(
    tables: List[Table],
    namingStrategy: NamingStrategy,
    options: CodegenOptions,
    customGen: CustomGenerator
) {

  def generateAggregateRoot(rootTableName: String, uniqueId: String = "id", maxDepth: Int = 3): Unit = {
    val startTime = System.currentTimeMillis()
    Class.forName(options.jdbcDriver)
    val db: Connection = DriverManager.getConnection(options.url, options.user, options.password)
    
    // Initialize auto-generated column attribute type mappings from database constraints
    val autoMappings = ConnectionUtils.getColumnAttributeTypeMappingsFromConstraints(db)
    customGen.setAutoGeneratedColumnMappings(autoMappings)
    
    try {
      println(s"Generating aggregate root for table: $rootTableName")
      
      // 1. Build reference tree starting from root table
      val referenceTree = buildReferenceTree(db, rootTableName, maxDepth)
      println(s"Reference tree: $referenceTree")
      
      // 2. Generate aggregate state and event handler
      val aggregateName = namingStrategy.table(rootTableName)
      val baseStateCode = generateBaseAggregateState(rootTableName, referenceTree)
      val eventHandlerCode = generateAggregateEventHandler(rootTableName, referenceTree)
      val stateRepositoryCode = generateAggregateStateRepository(rootTableName, referenceTree)
      
      // 3. Write files for this aggregate
      writeAggregateFiles(aggregateName, baseStateCode, eventHandlerCode, stateRepositoryCode)
      
      // 6. Optionally generate Pekko Persistence actor
      if (options.generatePekkoActors) {
        val pekkoActorCode = generatePekkoAggregateActor(rootTableName, referenceTree)
        writeAggregateActor(aggregateName, pekkoActorCode)
      }
      
      val endTime = System.currentTimeMillis()
      println(s"Generated aggregate $aggregateName in ${endTime - startTime}ms")
      
    } finally {
      db.close()
    }
  }
  
  def buildReferenceTree(db: Connection, rootTableName: String, maxDepth: Int): ReferenceTree = {
    
    def isLikelyAggregateRoot(tableName: String): Boolean = {
      val rootPatterns = options.aggregateRootTables
      rootPatterns.contains(tableName.toLowerCase) ||
      options.aggregateBoundaryHints.getOrElse(tableName, false)
    }
    
    def traverse(tableName: String, depth: Int, visited: Set[String]): List[ReferenceNode] = {
      if (depth >= maxDepth || visited.contains(tableName)) {
        return List.empty
      }
      
      val refs = ConnectionUtils.getReferences(db, tableName, "id")
      
      refs.flatMap { ref =>
        // Stop traversal at other aggregate boundaries (unless it's depth 0, i.e., the root)
        if (depth > 0 && isLikelyAggregateRoot(ref.fromTableName)) {
          // Just store the ID reference, don't traverse deeper
          Some(ReferenceNode(
            table = ref.fromTableName,
            foreignKeyColumn = ref.fromColName,
            children = List.empty,
            isWeakReference = true,
            depth = depth
          ))
        } else {
          // Continue traversing within this aggregate
          Some(ReferenceNode(
            table = ref.fromTableName,
            foreignKeyColumn = ref.fromColName,
            children = traverse(ref.fromTableName, depth + 1, visited + tableName),
            isWeakReference = false,
            depth = depth
          ))
        }
      }
    }
    
    ReferenceTree(rootTableName, traverse(rootTableName, 0, Set.empty))
  }

  def mergeOnFullWord(s1: String, s2: String): String = {
    val words1 = s1.split("_")
    val words2 = s2.split("_")

    // Find the longest overlap based on full words
    val maxOverlap = (1 to words1.length).findLast { i =>
      words2.startsWith(words1.takeRight(i))
    }.getOrElse(0)

    // Merge by removing the overlapping words from s2
    val mergedWords = words1 ++ words2.drop(maxOverlap)
    mergedWords.mkString("_")
  }

  def generateFieldName(ref: ReferenceNode, allRefs: List[ReferenceNode]): String = {
    val baseColumnName = ref.foreignKeyColumn.replace("_id", "")
    val baseName = snakeToLowerCamel(baseColumnName)
    val tableName = namingStrategy.table(ref.table)
    
    // Create base field name
    val fieldName = if (baseColumnName == "id") {
      s"${tableName.toLowerCase}Ids"
    } else if (baseName.toLowerCase.contains(tableName.toLowerCase)) {
      s"${baseName}Ids"
    } else {
      s"${baseName}${tableName}Ids"
    }
    
    // Check for conflicts and disambiguate
    val conflicts = allRefs.count { otherRef =>
      val otherBaseColumnName = otherRef.foreignKeyColumn.replace("_id", "")
      val otherBaseName = snakeToLowerCamel(otherBaseColumnName)
      val otherTableName = namingStrategy.table(otherRef.table)
      val otherFieldName = if (otherBaseColumnName == "id") {
        s"${otherTableName.toLowerCase}Ids"
      } else if (otherBaseName.toLowerCase.contains(otherTableName.toLowerCase)) {
        s"${otherBaseName}Ids"
      } else {
        s"${otherBaseName}${otherTableName}Ids"
      }
      otherFieldName == fieldName
    }
    
    if (conflicts > 1) {
      // Add table name for disambiguation
      s"${baseName}${namingStrategy.table(ref.table)}Ids"
    } else {
      fieldName
    }
  }

  def generateNestedMapFieldName(parentNode: ReferenceNode, childNode: ReferenceNode, allPairs: List[ParentChildPair]): String = {
    val parentTableName = namingStrategy.table(parentNode.table).toLowerCase
    val childTableName = namingStrategy.table(childNode.table).toLowerCase
    val parentBaseColumnName = parentNode.foreignKeyColumn.replace("_id", "")
    val childBaseColumnName = childNode.foreignKeyColumn.replace("_id", "")
    val parentBaseName = snakeToLowerCamel(parentBaseColumnName)
    val childBaseName = snakeToLowerCamel(childBaseColumnName)
    
    // Create base field name
    val baseFieldName = if (parentBaseColumnName == "id") {
      s"${parentTableName}${childTableName.capitalize}"
    } else if (childBaseColumnName == "id") {
      s"${parentBaseName}${childTableName.capitalize}"
    } else {
      s"${parentBaseName}${childBaseName.capitalize}"
    }
    
    // Check for conflicts and disambiguate
    val conflicts = allPairs.count { otherPair =>
      val otherParentTableName = namingStrategy.table(otherPair.parentNode.table).toLowerCase
      val otherChildTableName = namingStrategy.table(otherPair.childNode.table).toLowerCase
      val otherParentBaseColumnName = otherPair.parentNode.foreignKeyColumn.replace("_id", "")
      val otherChildBaseColumnName = otherPair.childNode.foreignKeyColumn.replace("_id", "")
      val otherParentBaseName = snakeToLowerCamel(otherParentBaseColumnName)
      val otherChildBaseName = snakeToLowerCamel(otherChildBaseColumnName)
      
      val otherBaseFieldName = if (otherParentBaseColumnName == "id") {
        s"${otherParentTableName}${otherChildTableName.capitalize}"
      } else if (otherChildBaseColumnName == "id") {
        s"${otherParentBaseName}${otherChildTableName.capitalize}"
      } else {
        s"${otherParentBaseName}${otherChildBaseName.capitalize}"
      }
      otherBaseFieldName == baseFieldName
    }
    
    if (conflicts > 1) {
      // Add more specificity for disambiguation
      s"${parentTableName}${parentBaseName.capitalize}${childTableName.capitalize}${childBaseName.capitalize}"
    } else {
      baseFieldName
    }
  }

  def generateBaseAggregateState(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    
    // Direct children (store as List[EntityId])
    val directRefs = tree.nodes.filter(node => node.depth == 0)
    val directIdFields = directRefs.map { ref =>
      val fieldName = generateFieldName(ref, directRefs)
      s"  $fieldName: List[${namingStrategy.table(singularize(ref.table))}Id] = List.empty"
    }
    
    // Nested Maps for children of children (e.g., postComments: Map[PostId, List[CommentId]])
    // First collect all parent-child pairs for unique naming
    val nestedPairs = tree.nodes.flatMap { parentNode =>
      if (!parentNode.isWeakReference) {
        parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
          ParentChildPair(parentNode, childNode)
        }
      } else {
        List.empty
      }
    }
    
    val nestedMaps = nestedPairs.map { pair =>
      val parentId = s"${namingStrategy.table(singularize(pair.parentNode.table))}Id"
      val childId = s"${namingStrategy.table(singularize(pair.childNode.table))}Id"
      val fieldName = generateNestedMapFieldName(pair.parentNode, pair.childNode, nestedPairs)
      s"  $fieldName: Map[$parentId, List[$childId]] = Map.empty"
    }
    
    val allFields = directIdFields ++ nestedMaps
    val fieldsString = {
      val metadataComment = ",\n  \n  // Event sourcing metadata"
      if (allFields.nonEmpty) {
        val childrenSection = ",\n  \n  // Direct children\n" + allFields.mkString(",\n")
        childrenSection + metadataComment
      } else {
        metadataComment
      }
    }
    
    s"""package ${options.packageName}.aggregates.${rootEntityFieldName}

${GeneratorTemplates.autoGeneratedComment}

//import scala.concurrent.Future
//import monix.eval.Task
import escalator.ddd.Event
import escalator.models.CorrelationId
import escalator.util.Timestamp
import ${options.packageName}.models._
import ${options.packageName}.models.events._

/**
 * Base aggregate state for ${aggregateName}
 * Contains the root entity plus IDs of all related entities
 */
case class Base${aggregateName}State(
  ${rootEntityFieldName}: Option[${aggregateName}] = None${fieldsString}
  version: Long = 0L,
  lastUpdated: Timestamp = Timestamp(0L)
) {
  /**
   * Apply an event to update the aggregate state
   */
  def applyEvent(event: Event): Base${aggregateName}State = event match {
    case e: ${aggregateName}Event => ${aggregateName}EventHandler.apply(this, e)${generateEventMatchCases(tree, aggregateName)}
    case _ => this  // Ignore unrelated events
  }
}

object Base${aggregateName}State {
  def empty(${rootEntityFieldName}Id: ${aggregateName}Id): Base${aggregateName}State = {
    Base${aggregateName}State(
      ${rootEntityFieldName} = None,
      version = 0L,
      lastUpdated = Timestamp(0L)
    )
  }
}
"""
  }
  
  def generateEventMatchCases(tree: ReferenceTree, aggregateName: String): String = {
    // Deduplicate by table name to avoid duplicate event cases
    val uniqueTables = tree.nodes.filter(node => !node.isWeakReference).map(_.table).distinct
    val eventCases = uniqueTables.map { table =>
      val eventName = namingStrategy.table(singularize(table))
      s"""
    case e: ${eventName}Event => ${aggregateName}EventHandler.apply(this, e)"""
    }
    eventCases.mkString
  }
  
  def generateAggregateEventHandler(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    
    // Generate handler methods for each event type
    val rootEventHandler = generateRootEventHandler(rootTableName, aggregateName)
    // Deduplicate by table name to avoid duplicate handlers for the same entity type
    val uniqueChildTables = tree.nodes.filter(node => !node.isWeakReference).map(_.table).distinct
    val childEventHandlers = uniqueChildTables.map { tableName =>
      // Find a representative node for this table
      val representativeNode = tree.nodes.find(_.table == tableName).get
      generateChildEventHandler(rootTableName, representativeNode, tree, aggregateName)
    }.mkString("\n")
    
    s"""package ${options.packageName}.aggregates.${rootEntityFieldName}

${GeneratorTemplates.autoGeneratedComment}

import escalator.ddd.Event
import escalator.models.CorrelationId
import escalator.util.Timestamp
import ${options.packageName}.models._
import ${options.packageName}.models.events._

/**
 * Pure event handlers for ${aggregateName} aggregate
 * These are side-effect free functions for applying events to state
 */
object ${aggregateName}EventHandler {
  
$rootEventHandler
  
$childEventHandlers
}
"""
  }
  
  def generateRootEventHandler(rootTableName: String, aggregateName: String): String = {
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    s"""  /**
   * Handle events for the root ${aggregateName} entity
   */
  def apply(state: Base${aggregateName}State, event: ${aggregateName}Event): Base${aggregateName}State = {
    event match {
      case ${aggregateName}Created($rootEntityFieldName, _, correlationId, timestamp) =>
        state.copy(
          $rootEntityFieldName = Some($rootEntityFieldName),
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case ${aggregateName}Updated($rootEntityFieldName, previous${aggregateName}, _, correlationId, timestamp) =>
        state.copy(
          $rootEntityFieldName = Some($rootEntityFieldName),
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case ${aggregateName}Deleted($rootEntityFieldName, _, correlationId, timestamp) =>
        // Mark as deleted by setting to None
        state.copy(
          $rootEntityFieldName = None,
          version = state.version + 1,
          lastUpdated = timestamp
        )
    }
  }"""
  }
  
  def generateChildEventHandler(rootTableName: String, node: ReferenceNode, tree: ReferenceTree, aggregateName: String): String = {
    val childName = namingStrategy.table(singularize(node.table))
    val childNameLower = node.table.toLowerCase
    val foreignKeyCheck = generateForeignKeyCheck(node, rootTableName)
    val nestedUpdates = generateNestedUpdates(node, tree)
    val depthDescription = if (node.depth == 0) "direct children" else s"depth ${node.depth}"
    
    // Use consistent field naming for direct children
    val directRefs = tree.nodes.filter(n => n.depth == 0 && !n.isWeakReference)
    val fieldName = generateFieldName(node, directRefs)
    
    s"""  /**
   * Handle events for ${childName} entities ($depthDescription)
   */
  def apply(state: Base${aggregateName}State, event: ${childName}Event): Base${aggregateName}State = {
    event match {
      case ${childName}Created(${childNameLower}, _, correlationId, timestamp) if $foreignKeyCheck =>
        state.copy(
          $fieldName = state.$fieldName :+ ${childNameLower}.id,
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case ${childName}Updated(${childNameLower}, previous${childName}, _, correlationId, timestamp) if $foreignKeyCheck =>
        // No ID changes needed for updates
        state.copy(
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case ${childName}Deleted(${childNameLower}, _, correlationId, timestamp) if $foreignKeyCheck =>
        state.copy(
          $fieldName = state.$fieldName.filterNot(_ == ${childNameLower}.id),$nestedUpdates
          version = state.version + 1,
          lastUpdated = timestamp
        )
        
      case _ => state  // Event not relevant to this aggregate
    }
  }"""
  }
  
  def generateForeignKeyCheck(node: ReferenceNode, rootTableName: String): String = {
    if (node.depth == 0) {
      // Direct child - check against root entity ID (now Optional)
      val rootEntityFieldName = singularize(rootTableName.toLowerCase)
      // Convert database column name (user_id) to Scala property name (userId)
      val scalaPropertyName = namingStrategy.column(node.foreignKeyColumn)
      s"state.$rootEntityFieldName.exists(_.id == ${node.table.toLowerCase}.$scalaPropertyName)"
    } else {
      // Nested child - check if parent is in our collection
      val parentTable = findParentTable(node, rootTableName)
      val parentIdField = TextUtil.snakeToLowerCamel(parentTable) + "Ids"  // parentTable is already plural
      // Convert database column name to Scala property name
      val scalaPropertyName = namingStrategy.column(node.foreignKeyColumn)
      s"state.$parentIdField.contains(${node.table.toLowerCase}.$scalaPropertyName)"
    }
  }
  
  def generateNestedUpdates(node: ReferenceNode, tree: ReferenceTree): String = {
    if (node.children.nonEmpty) {
      // Generate all nested pairs for consistent naming
      val nestedPairs = tree.nodes.flatMap { parentNode =>
        if (!parentNode.isWeakReference) {
          parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
            ParentChildPair(parentNode, childNode)
          }
        } else {
          List.empty
        }
      }
      
      val childCleanups = node.children.filter(!_.isWeakReference).map { child =>
        val mapField = generateNestedMapFieldName(node, child, nestedPairs)
        s"$mapField = state.$mapField - ${node.table.toLowerCase}.id"
      }
      "\n          " + childCleanups.mkString(",\n          ") + ","
    } else {
      ""
    }
  }
  
  def findParentTable(node: ReferenceNode, rootTableName: String): String = {
    // This is a simplified approach - in a full implementation,
    // you'd need to traverse the tree to find the actual parent
    rootTableName
  }
  
  def generateAggregateStateRepository(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    
    // Generate repository dependencies (existing repositories for each table)
    val uniqueTables = (rootTableName :: tree.allTables.filter(table => table != rootTableName)).distinct
    val repoDependencies = uniqueTables.map { tableName =>
      val repoName = s"${pluralize(namingStrategy.table(tableName))}Repository"
      s"  ${TextUtil.snakeToLowerCamel(tableName)}Repo: $repoName"
    }.mkString(",\n")
    val uniqueRepoParams = uniqueTables.map(t => s"${TextUtil.snakeToLowerCamel(t)}Repo").mkString(", ")
    
    // Generate loading logic for each level
    val loadingLogic = generateStateLoadingLogic(rootTableName, tree, aggregateName)
    
    s"""package ${options.packageName}.aggregates.${rootEntityFieldName}

${GeneratorTemplates.autoGeneratedComment}

import scala.concurrent.{ExecutionContext, Future}
import com.typesafe.scalalogging.Logger
import escalator.ddd.Event
import escalator.models.CorrelationId
import escalator.util.{Timestamp, TimeUtil}
import ${options.packageName}.models._
import ${options.packageName}.models.events._
import ${options.packageName}.core.repositories.postgres._

import monix.eval.Task
import escalator.util.monix.TaskSyntax._


/**
 * Repository for loading and managing ${aggregateName} aggregate state
 * Supports both DB bootstrapping and event replay
 */
class ${aggregateName}StateRepository(
$repoDependencies
)(implicit ec: ExecutionContext, logger: Logger) {
  
  /**
   * Load complete aggregate state from database
   */
  def load${aggregateName}State(${rootEntityFieldName}Id: ${aggregateName}Id): Task[Option[Base${aggregateName}State]] = {
$loadingLogic
  }
  
  /**
   * Load multiple states efficiently
   */
  def load${aggregateName}States(ids: List[${aggregateName}Id]): Task[Map[${aggregateName}Id, Base${aggregateName}State]] = {
    Task.sequence(ids.map { id =>
      load${aggregateName}State(id).map(stateOpt => id -> stateOpt)
    }).map(_.collect { case (id, Some(state)) => id -> state }.toMap)
  }
  
  /**
   * Replay events to rebuild state (Pekko Persistence compatible)
   */
  def replay${aggregateName}State(${rootEntityFieldName}Id: ${aggregateName}Id, fromSequenceNr: Long = 0L): Task[Base${aggregateName}State] = {
    // This method would integrate with your event store
    // For now, return empty state as placeholder
    Task.pure(Base${aggregateName}State.empty(${rootEntityFieldName}Id))
  }
  
  /**
   * Apply events to state in sequence
   */
  def applyEvents(initialState: Base${aggregateName}State, events: List[Event]): Base${aggregateName}State = {
    events.foldLeft(initialState)(_.applyEvent(_))
  }
}

object ${aggregateName}StateRepository {
  def apply(
$repoDependencies
  )(implicit ec: ExecutionContext, logger: Logger): ${aggregateName}StateRepository = 
    new ${aggregateName}StateRepository($uniqueRepoParams)
}
"""
  }
  
  def generateStateLoadingLogic(rootTableName: String, tree: ReferenceTree, aggregateName: String): String = {
    val rootEntityFieldName = singularize(rootTableName.toLowerCase)
    s"""    for {
      // Load root entity
      ${rootEntityFieldName}Opt <- Task.fromFuture(${TextUtil.snakeToLowerCamel(rootTableName)}Repo.getById(${rootEntityFieldName}Id))
      
      state <- ${rootEntityFieldName}Opt match {
        case None => Task.pure(None)
        case Some(${rootEntityFieldName}) =>
          for {
${generateDirectChildrenLoading(tree)}
${generateNestedChildrenLoading(tree)}
            
          } yield Some(Base${aggregateName}State(
            ${rootEntityFieldName} = Some(${rootEntityFieldName}),
${generateStateConstruction(tree)}
            version = 0L,
            lastUpdated = TimeUtil.nowTimestamp()
          ))
      }
    } yield state"""
  }
  
  def generateDirectChildrenLoading(tree: ReferenceTree): String = {
    val directChildren = tree.nodes.filter(node => node.depth == 0 && !node.isWeakReference)
    if (directChildren.nonEmpty) {
      val loadingTasks = directChildren.map { node =>
        // node.table is already plural, don't pluralize again
        val tableName = node.table
        val foreignKeyMethodName = s"getBy${namingStrategy.table(node.foreignKeyColumn).capitalize}"
        s"Task.fromFuture(${TextUtil.snakeToLowerCamel(tableName)}Repo.${foreignKeyMethodName}(${singularize(tree.rootTable.toLowerCase)}Id))"
      }
      
      if (directChildren.size == 1) {
        // Single task - no need for parMap
        val varName = generateFieldName(directChildren.head, directChildren).replace("Ids", "s")
        s"""            // Load direct children
            $varName <- ${loadingTasks.head}"""
      } else {
        // Multiple tasks - use parMapN (up to 10) or parSequence
        val taskCount = directChildren.size
        if (taskCount >= 2 && taskCount <= 10) {
          val paramNames = directChildren.zipWithIndex.map { case (_, i) => s"p$i" }
          val combiningFunction = s"((${paramNames.mkString(", ")}) => (${paramNames.mkString(", ")}))"
          val varNames = directChildren.map(node => generateFieldName(node, directChildren).replace("Ids", "s")).mkString(", ")
          s"""            // Load direct children in parallel
            ($varNames) <- Task.parMap$taskCount(
              ${loadingTasks.mkString(",\n              ")}
            )$combiningFunction"""
        } else {
          // For large numbers of tasks, assign each variable individually with explicit types
          val loadingCode = s"""            // Load direct children in parallel - many children (${taskCount})
            allChildren <- Task.parSequence(List(
              ${loadingTasks.mkString(",\n              ")}
            ))"""
          
          val assignmentCode = directChildren.zipWithIndex.map { case (node, i) =>
            val varName = generateFieldName(node, directChildren).replace("Ids", "s")
            val modelName = namingStrategy.table(singularize(node.table)) // Convert plural table to singular model
            s"            $varName = allChildren($i).asInstanceOf[List[$modelName]]"
          }.mkString("\n")
          
          s"""$loadingCode
$assignmentCode"""
        }
      }
    } else {
      "            // No direct children to load"
    }
  }
  
  def resolveForeignKeyType(foreignKeyColumn: String): String = {
    // Handle special cases where foreign keys reference specific known types
    foreignKeyColumn.replace("_id", "") match {
      case "ref_message" | "post" => "MessageId"
      case columnBase => s"${namingStrategy.table(singularize(columnBase))}Id"
    }
  }

  def generateNestedChildrenLoading(tree: ReferenceTree): String = {
    val nestedNodes = tree.nodes.filter(node => node.children.nonEmpty)
    if (nestedNodes.nonEmpty) {
      // Generate all nested pairs for consistent naming
      val nestedPairs = tree.nodes.flatMap { parentNode =>
        if (!parentNode.isWeakReference) {
          parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
            ParentChildPair(parentNode, childNode)
          }
        } else {
          List.empty
        }
      }
      
      val loadingLogic = nestedPairs.map { pair =>
        val parentNode = pair.parentNode
        val childNode = pair.childNode
        // Both parentNode.table and childNode.table are already plural
        val parentRefs = tree.nodes.filter(node => node.depth == 0 && !node.isWeakReference)
        val parentVarName = generateFieldName(parentNode, parentRefs).replace("Ids", "s")
        val mapVarName = s"${TextUtil.snakeToLowerCamel(singularize(parentNode.table))}${TextUtil.snakeToUpperCamel(childNode.foreignKeyColumn.replace("_id", ""))}${namingStrategy.table(childNode.table)}Map"
        val foreignKeyType = resolveForeignKeyType(childNode.foreignKeyColumn)
        
        s"""            // Load ${childNode.table} for each ${parentNode.table}
            $mapVarName <- if ($parentVarName.nonEmpty) {
              Task.fromFuture(${TextUtil.snakeToLowerCamel(childNode.table)}Repo.getBy${namingStrategy.table(childNode.foreignKeyColumn).capitalize}s($parentVarName.map(_.id)))
                .map(_.groupBy(_.${namingStrategy.column(childNode.foreignKeyColumn)}).map { case (k, v) => k -> v.map(_.id) }.asInstanceOf[Map[$foreignKeyType, List[${namingStrategy.table(singularize(childNode.table))}Id]]])
            } else {
              Task.pure(Map.empty[$foreignKeyType, List[${namingStrategy.table(singularize(childNode.table))}Id]])
            }"""
      }.mkString("\n")
      
      s"""            // Load nested children
$loadingLogic"""
    } else {
      ""
    }
  }
  
  def generateStateConstruction(tree: ReferenceTree): String = {
    val directRefs = tree.nodes.filter(node => node.depth == 0 && !node.isWeakReference)
    val directChildIds = directRefs.map { node =>
      val fieldName = generateFieldName(node, directRefs)
      val varName = fieldName.replace("Ids", "s")
      s"            $fieldName = $varName.map(_.id),"
    }
    
    // Generate nested maps with consistent naming
    val nestedPairs = tree.nodes.flatMap { parentNode =>
      if (!parentNode.isWeakReference) {
        parentNode.children.filter(child => !child.isWeakReference).map { childNode =>
          ParentChildPair(parentNode, childNode)
        }
      } else {
        List.empty
      }
    }
    
    val nestedMaps = nestedPairs.map { pair =>
      val fieldName = generateNestedMapFieldName(pair.parentNode, pair.childNode, nestedPairs)
      val varName = s"${TextUtil.snakeToLowerCamel(singularize(pair.parentNode.table))}${TextUtil.snakeToUpperCamel(pair.childNode.foreignKeyColumn.replace("_id", ""))}${namingStrategy.table(pair.childNode.table)}Map"
      s"            $fieldName = $varName,"
    }
    
    (directChildIds ++ nestedMaps).mkString("\n")
  }
  
  def writeAggregateFiles(aggregateName: String, baseStateCode: String, eventHandlerCode: String, stateRepositoryCode: String): Unit = {
    val aggregateFolder = if (options.aggregatesFolder.nonEmpty) {
      s"${options.aggregatesFolder}/${aggregateName.toLowerCase}"
    } else {
      s"${options.persistenceBaseFolder}/aggregates/${aggregateName.toLowerCase}"
    }
    
    FileUtil.createDirectoriesForFolder(aggregateFolder)
    FileUtil.createDirectoriesForFolder(s"$aggregateFolder/custom")
    
    // Write generated files
    writeIfDoesNotExist(s"$aggregateFolder/Base${aggregateName}State.scala", formatCode(baseStateCode))
    writeIfDoesNotExist(s"$aggregateFolder/${aggregateName}EventHandler.scala", formatCode(eventHandlerCode))
    writeIfDoesNotExist(s"$aggregateFolder/${aggregateName}StateRepository.scala", formatCode(stateRepositoryCode))
    
    // Write custom extension files (only if they don't exist)
    val customStateCode = generateCustomStateTemplate(aggregateName)
    writeIfDoesNotExist(s"$aggregateFolder/custom/${aggregateName}State.scala", formatCode(customStateCode))
    
    val customLogicCode = generateCustomLogicTemplate(aggregateName)
    writeIfDoesNotExist(s"$aggregateFolder/custom/${aggregateName}BusinessLogic.scala", formatCode(customLogicCode))
  }
  
  def generateCustomStateTemplate(aggregateName: String): String = {
    s"""package ${options.packageName}.aggregates.${aggregateName.toLowerCase}.custom

// This file is never overwritten by the generator
// Add your custom state extensions and business logic here

import ${options.packageName}.aggregates.${aggregateName.toLowerCase}.Base${aggregateName}State
import ${options.packageName}.models._

/**
 * Extended ${aggregateName} state with custom business logic
 * Extend Base${aggregateName}State and add your domain-specific methods
 */
case class ${aggregateName}State(base: Base${aggregateName}State) {
  
  // Delegate to base state
  def ${aggregateName.toLowerCase} = base.${aggregateName.toLowerCase}
  def version = base.version
  def lastUpdated = base.lastUpdated
  
  // Add your custom computed properties here
  // Example:
  // def totalPosts: Int = base.postsIds.size
  // def isActive: Boolean = base.user.status == "active"
  
  // Add your custom business logic methods here
  // Example:
  // def canCreatePost: Boolean = isActive && totalPosts < 100
}

object ${aggregateName}State {
  def fromBase(baseState: Base${aggregateName}State): ${aggregateName}State = 
    ${aggregateName}State(baseState)
}
"""
  }
  
  def generateCustomLogicTemplate(aggregateName: String): String = {
    s"""package ${options.packageName}.aggregates.${aggregateName.toLowerCase}.custom

// This file is never overwritten by the generator
// Add your custom business logic and domain services here

import scala.concurrent.Future
import monix.eval.Task
import escalator.ddd.Event
import ${options.packageName}.aggregates.${aggregateName.toLowerCase}.Base${aggregateName}State
import ${options.packageName}.models._
import ${options.packageName}.models.events._

/**
 * Business logic for ${aggregateName} aggregate
 * Add your domain-specific operations here
 */
class ${aggregateName}BusinessLogic {
  
  /**
   * Example business rule validation
   */
  def validate${aggregateName}Creation(data: ${aggregateName}): Task[Either[String, ${aggregateName}]] = {
    // Add your validation logic here
    Task.pure(Right(data))
  }
  
  /**
   * Example business operation
   */
  def process${aggregateName}Command(state: Base${aggregateName}State, command: Any): Task[List[Event]] = {
    // Add your command processing logic here
    Task.pure(List.empty)
  }
  
  // Add more business logic methods as needed
}

object ${aggregateName}BusinessLogic {
  def apply(): ${aggregateName}BusinessLogic = new ${aggregateName}BusinessLogic()
}
"""
  }
  
  def writeAggregateActor(aggregateName: String, pekkoActorCode: String): Unit = {
    val aggregateFolder = if (options.aggregatesFolder.nonEmpty) {
      s"${options.aggregatesFolder}/${aggregateName.toLowerCase}"
    } else {
      s"${options.persistenceBaseFolder}/aggregates/${aggregateName.toLowerCase}"
    }
    
    writeIfDoesNotExist(s"$aggregateFolder/${aggregateName}Aggregate.scala", formatCode(pekkoActorCode))
  }
  
  def generatePekkoAggregateActor(rootTableName: String, tree: ReferenceTree): String = {
    val aggregateName = namingStrategy.table(rootTableName)
    
    s"""package ${options.packageName}.aggregates.${rootTableName.toLowerCase}

${GeneratorTemplates.autoGeneratedComment}

import org.apache.pekko.actor.typed.{ActorRef, Behavior}
import org.apache.pekko.persistence.typed.{PersistenceId, RecoveryCompleted}
import org.apache.pekko.persistence.typed.scaladsl.{Effect, EventSourcedBehavior, ReplyEffect}
import escalator.ddd.{Command, Event}
import escalator.models.CorrelationId
import escalator.util.{Timestamp, TimeUtil}
import ${options.packageName}.models._
import ${options.packageName}.models.events._

/**
 * Pekko Persistence EventSourced actor for ${aggregateName} aggregate
 */
object ${aggregateName}Aggregate {
  
  // Commands
  sealed trait ${aggregateName}Command extends Command
  
  case class Create${aggregateName}(
    data: ${aggregateName},
    correlationId: CorrelationId,
    replyTo: ActorRef[${aggregateName}Reply]
  ) extends ${aggregateName}Command
  
  case class Update${aggregateName}(
    data: ${aggregateName},
    correlationId: CorrelationId,
    replyTo: ActorRef[${aggregateName}Reply]
  ) extends ${aggregateName}Command
  
  case class Get${aggregateName}State(
    replyTo: ActorRef[${aggregateName}StateReply]
  ) extends ${aggregateName}Command
  
  // Replies
  sealed trait ${aggregateName}Reply
  case class ${aggregateName}Created(${rootTableName.toLowerCase}: ${aggregateName}) extends ${aggregateName}Reply
  case class ${aggregateName}Updated(${rootTableName.toLowerCase}: ${aggregateName}) extends ${aggregateName}Reply
  case class ${aggregateName}Error(message: String) extends ${aggregateName}Reply
  
  case class ${aggregateName}StateReply(state: Base${aggregateName}State)
  
  def apply(${rootTableName.toLowerCase}Id: ${aggregateName}Id): Behavior[${aggregateName}Command] = {
    EventSourcedBehavior[${aggregateName}Command, Event, Base${aggregateName}State](
      persistenceId = PersistenceId.ofUniqueId(s"${aggregateName}-$${${rootTableName.toLowerCase}Id.value}"),
      emptyState = Base${aggregateName}State.empty(${rootTableName.toLowerCase}Id),
      commandHandler = commandHandler,
      eventHandler = eventHandler
    )
  }
  
  private def commandHandler: (Base${aggregateName}State, ${aggregateName}Command) => ReplyEffect[Event, Base${aggregateName}State] = {
    (state, command) => command match {
      case Create${aggregateName}(data, correlationId, replyTo) =>
        if (state.version == 0L) {
          Effect.persist(${aggregateName}Created(data, data.id, correlationId, TimeUtil.nowTimestamp()))
            .thenReply(replyTo)(_ => ${aggregateName}Created(data))
        } else {
          Effect.reply(replyTo)(${aggregateName}Error("${aggregateName} already exists"))
        }
        
      case Update${aggregateName}(data, correlationId, replyTo) =>
        if (state.version > 0L) {
          Effect.persist(${aggregateName}Updated(data, Some(state.${rootTableName.toLowerCase}), data.id, correlationId, TimeUtil.nowTimestamp()))
            .thenReply(replyTo)(_ => ${aggregateName}Updated(data))
        } else {
          Effect.reply(replyTo)(${aggregateName}Error("${aggregateName} does not exist"))
        }
        
      case Get${aggregateName}State(replyTo) =>
        Effect.reply(replyTo)(${aggregateName}StateReply(state))
    }
  }
  
  private def eventHandler: (Base${aggregateName}State, Event) => Base${aggregateName}State = {
    (state, event) => state.applyEvent(event)
  }
}
"""
  }


  def applyFixes(fileData: String) = {
    // TODO: fix multi key foreign key
    customGen.processFileData(fileData)
  }

  def writeIfDoesNotExist(filePath: String, fileData: String) = {
    val fixedContent = applyFixes(fileData)

    FileUtil.writeIfDoesNotExist(filePath, fixedContent)
  }  

  def formatCode(code: String) = {
    Formatter.format(code)
    // code
  }

}
