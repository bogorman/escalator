package escalator.db.generators

// import scala.meta._
// import cats.syntax.arrow._
import escalator.util._

object GeneratorTemplates {
	import TextUtil._

	//TODO
	// id a deleted_at column exists then only do a soft delete by default
	// assumes 0L is id
	// assume rails format. ID SERIAL. CREATED_AT, UPDATED_AT.

	def autoGeneratedCommentTracker() = {
		"// THIS FILE IS AUTO-GENERATED. REMOVE THIS LINE TO STOP THIS FILE BEING RE-GENERATED"
	}

	def autoGeneratedCommentTime() = {
		s"// GENERATED AT: ${TimeUtil.nowString}"
	}

	def autoGeneratedComment() = {
		s"""
		|${autoGeneratedCommentTracker}
		|${autoGeneratedCommentTime}
		""".stripMargin
	}

	def genericDatabaseTemplate(packageSpace: String, appName: String, tableCaseClasses: List[String]) = {

		val tables = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	def ${objectName}: ${tableName}Table"
		}

		s"""
		package ${packageSpace}.persistence

		${autoGeneratedComment}

		import ${packageSpace}.persistence.database.tables._

		trait ${appName}Database {
			${tables.mkString("\n")}
		}
		"""
	}

	def postgresDatabaseTemplate(packageSpace: String, appName: String, tableCaseClasses: List[String]) = {
		val tables = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	object ${objectName} extends Postgres${tableName}Table(this) with PostgresCustomEncoder"
		}

		s"""
		package ${packageSpace}.persistence.postgres

		${autoGeneratedComment}

		import io.getquill._
		import escalator.util.logging.Logger

		import escalator.util.monitoring.Monitoring

		import monix.execution.Scheduler
		import ${packageSpace}.persistence.${appName}Database

		import ${packageSpace}.common.persistence.postgres.PostgresDatabase
		import ${packageSpace}.common.persistence.postgres.CustomNamingStrategy
		import ${packageSpace}.common.persistence.postgres.PostgresDatabase.PostgresDatabaseConfiguration
		import ${packageSpace}.common.persistence.postgres.PostgresCustomEncoder

		import ${packageSpace}.persistence.postgres.tables._

		class Postgres${appName}Database(
		  config: PostgresDatabaseConfiguration
		)(implicit
		  logger: Logger,
		  monitoring: Monitoring//,
		) extends PostgresDatabase (
		  new PostgresMonixJdbcContext(CustomNamingStrategy ,"postgres")
		) with ${appName}Database {

		  ///
		  ${tables.mkString("\n")}

		}

		"""
	}

	def canAddUpdateById(table: Table): Boolean = {
		// "StreamingSessions"
		// println("canAddUpdateById table.name:" + table.name)
		// (table.name == "streaming_sessions")
		// (table.name == "candles")
		true
	}

	def tableTraitTemplate(table: Table, packageSpace: String, modelClass: String, tableName: String, tableClass: String) = {
		val initial = modelClass.take(1).toLowerCase
		val primaryKeyClass = table.primaryKeyClass		//s"${modelClass}Id"

		val includeUpsert = table.hasUniqueKeysExcludingPrimaryKey()

		val upsert = DefnBuilder.buildUpsertsDefn(table, packageSpace, modelClass, tableName, tableClass)

		val uniqueChecks = DefnBuilder.buildUniqueCheckDefn(table, packageSpace, modelClass, tableName, tableClass)

		val updatesById = if (canAddUpdateById(table)) {
			DefnBuilder.buildUpdatesByIdDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val updatesByUniqueKeys = if (canAddUpdateById(table)) {
			DefnBuilder.buildUpdatesByUniqueKeysDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val gettersByUniqueKeys = if (canAddUpdateById(table)) {
			DefnBuilder.buildGettersByUniqueKeysDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		// val store = DefnBuilder.buildStoreDefn(table, packageSpace, modelClass, tableName, tableClass)

		s"""
		package ${packageSpace}.persistence.database.tables

		${autoGeneratedComment}

		import scala.concurrent.Future

		import ${packageSpace}.models._

		trait ${tableClass} {
		  def tableName = "${table.name.toLowerCase}"

		  def store(${initial}: ${modelClass}): Future[${modelClass}]

		  def store(${initial}l: List[${modelClass}]): Future[List[${modelClass}]]

		  def insert(${initial}: ${modelClass}): Future[_]

		  def update(${initial}: ${modelClass}): Future[_]

		  def upsert(${initial}: ${modelClass}): Future[${modelClass}]

		  def upsert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]]

		  ${upsert}

		  ${uniqueChecks}

		  ${updatesById}

		  ${updatesByUniqueKeys}

		  def delete(${initial}: ${modelClass}): Future[_]

		  def getById(${initial}: ${primaryKeyClass}): Future[Option[${modelClass}]] 

		  ${gettersByUniqueKeys}

		  def count: Future[Long]
		  
		  def getAll(): Future[List[${modelClass}]]
		}
		"""
	}

	def tableDaoTemplate(customGen: CustomGenerator,table: Table, packageSpace: String, modelClass: String, tableName: String, tableClass: String) = {
		// val package = ""
		val initial = modelClass.take(1).toLowerCase
		val primaryKeyClass = table.primaryKeyClass //s"${modelClass}Id"

		println("tableDaoTemplate:" + tableName)
		println(table.uniqueKeysExcludingPrimaryKey)

    	val upsert = CodeBuilder.buildUpsertsCode(table, packageSpace, modelClass, tableName, tableClass)

    	val uniqueChecks = CodeBuilder.buildUniqueCheckDefn(table, packageSpace, modelClass, tableName, tableClass)

		val updatesById = if (canAddUpdateById(table)) {
			CodeBuilder.buildUpdatesByIdCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val updatesByUniqueKeys = if (canAddUpdateById(table)) {
			CodeBuilder.buildUpdatesByUniqueKeysCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val gettersByUniqueKeys = if (canAddUpdateById(table)) {
			CodeBuilder.buildGettersByUniqueKeysCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

    // val store = CodeBuilder.buildStoreCode(table, packageSpace, modelClass, tableName, tableClass)		

		s"""
		package ${packageSpace}.persistence.postgres.tables

		${autoGeneratedComment}

		import scala.concurrent.Future

		import escalator.util.TimeUtil
		import escalator.util.logging.Logger
		import escalator.util.monitoring.Monitoring

		import ${packageSpace}.persistence.postgres.common.MonitoredPostgresOperation
		import ${packageSpace}.common.persistence.postgres.PostgresDatabase
		import ${packageSpace}.common.persistence.postgres.PostgresMappedEncoder
		import ${packageSpace}.common.persistence.postgres.PostgresCustomEncoder

		import ${packageSpace}.models._

		import ${packageSpace}.persistence.database.tables.${tableClass}

		abstract class Postgres${tableClass}(database: PostgresDatabase)
		  (implicit logger: Logger, 
		    monitoring: Monitoring)
		    extends ${tableClass}
		    with PostgresCustomEncoder
		    {

		  def db:PostgresDatabase = database 

		  import PostgresMappedEncoder._

		  import monix.execution.Scheduler.Implicits.global
		  import ctx._

		  ${customGen.customMappers(tableClass)}

		  def monitored(name: String) = MonitoredPostgresOperation(name, tableName)

		  override def store(${initial}: ${modelClass}): Future[${modelClass}] = monitored("store") {
		  	val ts = TimeUtil.nowTimestamp()
		  	
		  	val toInsert = ${initial}.copy(createdAt = ts, updatedAt = ts)

		    ctx.run(
		      query[${modelClass}]
		        .insert(lift(toInsert))
		        .returningGenerated(_.id)
		    ).runToFuture.map { newId =>
		    	toInsert.copy(id = newId)
		    }
		  }

		  override def store(${initial}l: List[${modelClass}]): Future[List[${modelClass}]] = monitored("store") {
		  	Future.sequence(  ${initial}l.map { ${initial} => store(${initial}) }  )
		  }

		  override def insert(${initial}: ${modelClass}): Future[${primaryKeyClass}] = monitored("insert") {
		  	val ts = TimeUtil.nowTimestamp()
		    ctx.run(
		      query[${modelClass}]
		        .insert(lift(${initial}.copy(createdAt = ts, updatedAt = ts)))
		        .returningGenerated(_.id)
		    ).runToFuture
		  }

		  override def update(${initial}: ${modelClass}): Future[${primaryKeyClass}] = monitored("update") {
		  	if (${initial}.id == ${primaryKeyClass}(0L)) {
		  		insert(${initial})
		  	} else {
		  		val ts = TimeUtil.nowTimestamp()
		  		ctx.run(
		  			query[${modelClass}]
		  				.filter(_.id == lift(${initial}.id))
		  				.update(lift(${initial}.copy(updatedAt = ts)))
		  				.returning(_.id)
		  		).runToFuture
		  	}
		  }

		  override def upsert(${initial}: ${modelClass}): Future[${modelClass}] = {
		  	if (${initial}.id == ${primaryKeyClass}(0L)) {
		  		store(${initial})
		  	} else {
		  		val ts = TimeUtil.nowTimestamp()
		  		ctx.run(
		  			query[${modelClass}]
		  				.filter(_.id == lift(${initial}.id))
		  				.update(lift(${initial}.copy(updatedAt = ts)))
		  				.returning(_.id)
		  		).runToFuture.map { updatedId =>
			    	${initial}.copy(updatedAt = ts)
			    }
		  	}
		  }		  

		  override def upsert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]] = {
		  	Future.sequence(  ${initial}l.map { ${initial} => upsert(${initial}) }  )
		  }		  

		  ${upsert}

		  ${uniqueChecks}

		  ${updatesById}

		  ${updatesByUniqueKeys}

		  override def delete(${initial}: ${modelClass}): Future[${primaryKeyClass}] = monitored("delete") {
		    ctx.run(
		      query[${modelClass}]
		      	.filter(_.id == lift(${initial}.id))
		        .delete
		        .returning(_.id)
		    ).runToFuture
		  }

		  override def getById(${initial}: ${primaryKeyClass}): Future[Option[${modelClass}]] = monitored("getById") {
            ctx.run(
                query[${modelClass}]
                  .filter(_.id == lift(${initial}))
                  .take(1)
            ).runToFuture.map(_.headOption)
		  }

		  ${gettersByUniqueKeys}

		  override def count: Future[Long] = monitored("count") {
		    ctx.run(query[${modelClass}].size).runToFuture
		  }

		  override def getAll(): Future[List[${modelClass}]] = monitored("get_all") { 
            ctx.run(
                query[${modelClass}]
            ).runToFuture
		  }		  

		}
		"""	
	}


}