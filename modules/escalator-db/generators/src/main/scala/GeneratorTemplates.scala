package escalator.db.generators

// import scala.meta._
// import cats.syntax.arrow._
import escalator.util._

object GeneratorTemplates {
	import TextUtil._

	//TODO
	// id a deleted_at column exists then only do a soft delete by default
	// assumes 0L is id
	// assume rails format. ID SERIAL. CREATED_AT, UPDATED_AT.

	def autoGeneratedCommentTracker() = {
		"// THIS FILE IS AUTO-GENERATED. REMOVE THIS LINE TO STOP THIS FILE BEING RE-GENERATED"
	}

	def autoGeneratedCommentTime() = {
		s"// GENERATED AT: ${TimeUtil.nowString}"
	}

	def autoGeneratedComment() = {
		s"""
		|${autoGeneratedCommentTracker}
		|${autoGeneratedCommentTime}
		""".stripMargin
	}

	def genericDatabaseTemplate(packageSpace: String, appName: String, tableCaseClasses: List[String]) = {

		val tables = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	def ${objectName}: ${tableName}Table"
		}

		s"""
		package ${packageSpace}.persistence

		${autoGeneratedComment}

		import ${packageSpace}.persistence.database.tables._

		trait ${appName}Database {
			${tables.mkString("\n")}
		}
		"""
	}

	// s"	object ${objectName} extends ${tcc}Repository(this)"
	def postgresDatabaseTemplate(packageSpace: String, appName: String, tableCaseClasses: List[String]) = {
		val tables = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	object ${objectName} extends Postgres${tableName}Table(this) with PostgresCustomEncoder"
		}

		val tables2 = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	//	object ${objectName} extends ${tableName}Repository(this)"
		}		

		s"""
		package ${packageSpace}.persistence.postgres

		${autoGeneratedComment}

		import io.getquill._
		import escalator.util.logging.Logger

		import escalator.util.monitoring.Monitoring
		import escalator.util.events.EventBus

		import monix.execution.Scheduler
		import ${packageSpace}.persistence.${appName}Database

		import escalator.util.postgres.PostgresDatabase
		import escalator.util.postgres.PostgresDatabase.PostgresDatabaseConfiguration
		import escalator.util.postgres.CustomNamingStrategy

		import ${packageSpace}.common.persistence.postgres.PostgresCustomEncoder
		import ${packageSpace}.common.persistence.postgres.PostgresMappedEncoder

		import ${packageSpace}.persistence.postgres.tables._
		import ${packageSpace}.persistence._

		class Postgres${appName}Database(
		  config: PostgresDatabaseConfiguration
		)(implicit
		  logger: Logger,
		  monitoring: Monitoring,
		  eventBus: EventBus
		) extends PostgresDatabase (
		  new PostgresMonixJdbcContext(CustomNamingStrategy ,"postgres")
		) with ${appName}Database {

		  ///
		  ${tables.mkString("\n")}

		  /// include these in your repository
		  ${tables2.mkString("\n")}
		}

		"""
	}

	def canAddUpdateById(table: Table): Boolean = {
		// "StreamingSessions"
		// println("canAddUpdateById table.name:" + table.name)
		// (table.name == "streaming_sessions")
		// (table.name == "candles")
		true
	}

	def tableTraitTemplate(table: Table, packageSpace: String, modelClass: String, tableName: String, tableClass: String) = {
		val initial = modelClass.take(1).toLowerCase
		val primaryKeyClass: Option[String] = table.primaryKeyClass		//s"${modelClass}Id"

		val includeUpsert = table.hasUniqueKeysExcludingPrimaryKey()

		val upsert = DefnBuilder.buildUpsertsDefn(table, packageSpace, modelClass, tableName, tableClass)

		val uniqueChecks = DefnBuilder.buildUniqueCheckDefn(table, packageSpace, modelClass, tableName, tableClass)

		val updatesById = if (canAddUpdateById(table)) {
			DefnBuilder.buildUpdatesByIdDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val updatesByUniqueKeys = if (canAddUpdateById(table)) {
			DefnBuilder.buildUpdatesByUniqueKeysDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val gettersByUniqueKeys = if (canAddUpdateById(table)) {
			DefnBuilder.buildGettersByUniqueKeysDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		// val store = DefnBuilder.buildStoreDefn(table, packageSpace, modelClass, tableName, tableClass)

		val primaryIdFuncs = if (primaryKeyClass.isEmpty){
			""
		} else {
			s"""
				def getById(${initial}: ${primaryKeyClass.get}): Future[Option[${modelClass}]]

				def update(${initial}: ${modelClass}): Future[${modelClass}]

				def upsert(${initial}: ${modelClass}): Future[${modelClass}]

				def upsert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]]				

				def delete(${initial}: ${modelClass}): Future[${modelClass}]
			"""
		}

		s"""
		package ${packageSpace}.persistence.database.tables

		${autoGeneratedComment}

		import scala.concurrent.Future

		import ${packageSpace}.models._

		trait ${tableClass} {
		  def tableName = "${table.name.toLowerCase}"

		  //def store(${initial}: ${modelClass}): Future[${modelClass}]

		  //def store(${initial}l: List[${modelClass}]): Future[List[${modelClass}]]

		  //def insert(${initial}: ${modelClass}): Future[_]

		  ${upsert}

		  ${uniqueChecks}

		  ${updatesById}

		  ${updatesByUniqueKeys}

		  ${primaryIdFuncs}

		  ${gettersByUniqueKeys}

		  def count: Future[Long]
		  
		  def getAll(): Future[List[${modelClass}]]
		}
		"""
	}

	def tableDaoTemplate(customGen: CustomGenerator, table: Table, packageSpace: String, modelClass: String, tableName: String, tableClass: String) = {
		// val package = ""
		val initial = modelClass.take(1).toLowerCase
		val primaryKeyClass: Option[String] = table.primaryKeyClass //s"${modelClass}Id"

		val pkFieldForCreated = if (primaryKeyClass.isDefined) {
			val pkField = table.primaryKeyCol.get.toArg(GeneratorNamingStrategy, table.name, true).split(":")(0).trim
			s"${pkField} = ${initial}.${pkField},"
		} else {
			""
		}
		
		val pkFieldForDeleted = pkFieldForCreated

		println("tableDaoTemplate:" + tableName)
		println(table.uniqueKeysExcludingPrimaryKey)

    	val upsert = CodeBuilder.buildUpsertsCode(table, packageSpace, modelClass, tableName, tableClass)

    	val uniqueChecks = CodeBuilder.buildUniqueCheckDefn(table, packageSpace, modelClass, tableName, tableClass)

		val updatesById = if (canAddUpdateById(table)) {
			CodeBuilder.buildUpdatesByIdCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val updatesByUniqueKeys = if (canAddUpdateById(table)) {
			CodeBuilder.buildUpdatesByUniqueKeysCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val gettersByUniqueKeys = if (canAddUpdateById(table)) {
			CodeBuilder.buildGettersByUniqueKeysCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

    // val store = CodeBuilder.buildStoreCode(table, packageSpace, modelClass, tableName, tableClass)	
    
		val returnClass = if (primaryKeyClass.isEmpty){
			"Long"
		} else {
			primaryKeyClass.get
		}

		val returningValues = if (primaryKeyClass.isEmpty){
			""
		} else {
			".returning(_.id)"
		}    	

		val updateTimeTracking = if (!table.hasColumn("updated_at")){
			""
		} else {
			".copy(updatedAt = ts)"
		}    

		val insertUpdateTimeTracking = if (!table.hasColumn("created_at")){
			""
		} else {
			".copy(createdAt = ts, updatedAt = ts)"
		}				

		// defaultConstructorValue()

		val primaryKeyCol = table.primaryKeyCol

		val defaultPrimaryValue = if (primaryKeyCol.isEmpty){
			""
		} else {
			val pc = primaryKeyCol.get
		    if (pc.scalaType == "java.util.UUID") {
		      "escalator.util.RichUUID.BLANK_UUID"
		    } else {
		      "0L"
		    }
		}	
		
		val pkFieldForUpdate = if (primaryKeyClass.isDefined) {
			val pkField = table.primaryKeyCol.get.toArg(GeneratorNamingStrategy, table.name, true).split(":")(0).trim
			s"${pkField} = updatedEntity.${pkField},"
		} else {
			""
		}
		

		val primaryIdFuncs = if (primaryKeyClass.isEmpty){
			""
		} else {

			s"""
			  override def getById(${initial}: ${primaryKeyClass.get}): Future[Option[${modelClass}]] = monitored("getById") {
			    read {
			      ctx.run(
			        query[${modelClass}]
			          .filter(_.id == lift(${initial}))
			          .take(1)
			      ).runToFuture.map(_.headOption)
			    }
			  }

			  override def update(${initial}: ${modelClass}): Future[${modelClass}] = monitored("update") {
			  	if (${initial}.id == ${primaryKeyClass.get}(${defaultPrimaryValue})) {
			  		insert(${initial})
			  	} else {
			  		val ts = TimeUtil.nowTimestamp()
			  		val updatedModel = ${initial}${updateTimeTracking}
			  		
			  		write(updatedModel) {
			  			ctx.run(
			  				query[${modelClass}]
			  					.filter(_.id == lift(${initial}.id))
			  					.update(lift(updatedModel))
			  			).runToFuture
			  		}.publishingUpdated((cur, prev, cid, time) => ${modelClass}Updated(cur, prev, ${pkFieldForCreated} cid, time))
			  	}
			  }

			  override def upsert(${initial}: ${modelClass}): Future[${modelClass}] = monitored("upsert") {
			  	if (${initial}.id == ${primaryKeyClass.get}(${defaultPrimaryValue})) {
			  		insert(${initial})
			  	} else {
			  		update(${initial})
			  	}
			  }		  

			  override def upsert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]] = {
			  	Future.sequence(  ${initial}l.map { ${initial} => upsert(${initial}) }  )
			  }	

			  override def delete(${initial}: ${modelClass}): Future[${modelClass}] = monitored("delete") {
			    val ts = TimeUtil.nowTimestamp()
			    
			    write(${initial}) {
			      ctx.run(
			        query[${modelClass}]
			          .filter(_.id == lift(${initial}.id))
			          .delete
			      ).runToFuture
			    }.publishingDeleted((m, cid, time) => ${modelClass}Deleted(m, ${pkFieldForDeleted} cid, time))
			  }

			"""
		}


		val returningGeneratedValues = if (primaryKeyClass.isEmpty){
			""
		} else {
			".returningGenerated(_.id)"
		}    			

		val storeClassUpdate = if (primaryKeyClass.isEmpty){
			s""".map{ rowCnt =>
		    	toInsert
		    }
		    """			
		} else {
			s""".map{ newId =>
		    	toInsert.copy(id = newId)
		    }
		    """			
		}
		
		// ${primaryKeyClass.get}(r
		val insertModelConstruction = if (primaryKeyClass.isEmpty) {
			"toInsert"
		} else {
			s"toInsert.copy(id = result)"
		}

		s"""
		package ${packageSpace}.persistence.postgres.tables

		${autoGeneratedComment}

		import scala.concurrent.Future

		import escalator.util.TimeUtil
		import escalator.util.logging.Logger
		import escalator.util.monitoring.Monitoring

		import escalator.util.postgres.MonitoredPostgresOperation
		import escalator.util.postgres.PostgresDatabase
		import escalator.util.postgres.PostgresDatabase.PostgresDatabaseConfiguration
		import escalator.util.postgres.CustomNamingStrategy
		import escalator.util.postgres.{EventRequiredResult, RepositoryHelpers}

		import escalator.util.events.EventBus
		import escalator.models.CorrelationId
		import java.util.UUID
		import escalator.util.Timestamp

		import ${packageSpace}.common.persistence.postgres.PostgresCustomEncoder
		import ${packageSpace}.common.persistence.postgres.PostgresMappedEncoder

		import ${packageSpace}.models._
		import ${packageSpace}.models.events._

		import ${packageSpace}.persistence.database.tables.${tableClass}

		import monix.eval.Task
		import escalator.util.monix.TaskSyntax._

		abstract class Postgres${tableClass}(database: PostgresDatabase)
		  (implicit logger: Logger, 
		    monitoring: Monitoring,
		    eventBus: EventBus)
		    extends ${tableClass}
		    with PostgresCustomEncoder
		    with RepositoryHelpers
		    {

		  def db:PostgresDatabase = database 

		  import PostgresMappedEncoder._

		  import monix.execution.Scheduler.Implicits.global
		  import ctx._

		  ${customGen.customMappers(tableClass)}

		  def monitored(name: String) = MonitoredPostgresOperation(name, tableName)


		  private def insert(${initial}: ${modelClass}): Future[${modelClass}] = monitored("insert") {
		  	val ts = TimeUtil.nowTimestamp()
		  	val toInsert = ${initial}${insertUpdateTimeTracking}

		    ctx.run(
		      query[${modelClass}]
		        .insert(lift(toInsert))
		        ${returningGeneratedValues}
		    ).runToFuture${storeClassUpdate}.flatMap { result =>
		      writeWithTimestamp(result, ts)(Future.successful(()))
		        .publishingCreated((m, cid, time) => ${modelClass}Created(m, ${pkFieldForCreated} cid, time))
		    }
		  }

		  private def insert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]] = monitored("insert") {
		  	Future.sequence(  ${initial}l.map { ${initial} => insert(${initial}) }  )
		  }

		  ${upsert}

		  ${uniqueChecks}

		  ${updatesById}

		  ${updatesByUniqueKeys}

		  ${primaryIdFuncs}

		  ${gettersByUniqueKeys}

		  override def count: Future[Long] = monitored("count") {
		    read {
		      ctx.run(query[${modelClass}].size).runToFuture
		    }
		  }

		  override def getAll(): Future[List[${modelClass}]] = monitored("get_all") { 
		    read {
		      ctx.run(
		        query[${modelClass}]
		      ).runToFuture
		    }
		  }		  

		}
		"""	
	}

	def appRepositoryTemplate(packageSpace: String, modelClass: String, tableName: String, tableClass: String, repositoriesFolder: String = "") = {
		val initial = modelClass.take(1).toLowerCase

		s"""
		package ${packageSpace}.core.repositories.postgres

		${autoGeneratedComment}

		import scala.concurrent.Future

		import escalator.util.logging.Logger
		import escalator.util.monitoring.Monitoring

		import escalator.util.postgres.PostgresDatabase
		import escalator.util.events.EventBus
		import ${packageSpace}.common.persistence.postgres.PostgresMappedEncoder

		import ${packageSpace}.models._
		import ${packageSpace}.persistence.database.tables.${tableClass}
		import ${packageSpace}.persistence.postgres.tables.Postgres${tableClass}

		class ${tableName}Repository(database: PostgresDatabase)
		  (implicit logger: Logger, 
		    monitoring: Monitoring,
		    eventBus: EventBus)
		    extends Postgres${tableClass}(database) {

		  // Override methods here to add custom repository logic
		  // This class inherits all standard CRUD operations from Postgres${tableClass}

		  import PostgresMappedEncoder._
		  import monix.execution.Scheduler.Implicits.global
		  import ctx._
		  
		}
		"""
	}

	def modelEventTemplate(packageSpace: String, modelClass: String, table: Table) = {
		val primaryKeyClass: Option[String] = table.primaryKeyClass
		val primaryKeyField = if (primaryKeyClass.isDefined) {
			val primaryKeyCol = table.primaryKeyCol.get
			s"${primaryKeyCol.toArg(GeneratorNamingStrategy, table.name, true)}"
		} else {
			"// No primary key available"
		}

		val correlationIdParam = if (primaryKeyClass.isDefined) {
			"correlationId: CorrelationId"
		} else {
			"correlationId: CorrelationId"
		}

		val primaryKeyParam = if (primaryKeyClass.isDefined) {
			s"${primaryKeyField},"
		} else {
			""
		}
		
		val primaryKeyDefInTrait = if (primaryKeyClass.isDefined) {
			s"def ${table.primaryKeyCol.get.toArg(GeneratorNamingStrategy, table.name, true)}"
		} else {
			""
		}

		s"""
		package ${packageSpace}.models.events

		${autoGeneratedComment}

		import java.time.Instant

		import escalator.ddd.{Event, PersistentEvent}
		import escalator.models.CorrelationId
		import escalator.util.Timestamp

		import ${packageSpace}.models._

		/**
		 * Events for ${modelClass} aggregate
		 */
		sealed trait ${modelClass}Event extends Event with PersistentEvent {
		  def ${modelClass.toLowerCase}: ${modelClass}
		  ${primaryKeyDefInTrait}
		  def correlationId: CorrelationId
		  def timestamp: Timestamp
		}

		case class ${modelClass}Created(
		  ${modelClass.toLowerCase}: ${modelClass},
		  ${primaryKeyParam}
		  ${correlationIdParam},
		  timestamp: Timestamp
		) extends ${modelClass}Event

		case class ${modelClass}Updated(
		  ${modelClass.toLowerCase}: ${modelClass},
		  previous${modelClass}: Option[${modelClass}] = None,
		  ${primaryKeyParam}
		  ${correlationIdParam},
		  timestamp: Timestamp
		) extends ${modelClass}Event

		case class ${modelClass}Deleted(
		  ${modelClass.toLowerCase}: ${modelClass},
		  ${primaryKeyParam}
		  ${correlationIdParam},
		  timestamp: Timestamp
		) extends ${modelClass}Event
		"""
	}


}