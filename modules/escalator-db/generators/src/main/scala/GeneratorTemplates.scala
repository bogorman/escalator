package escalator.db.generators

// import scala.meta._
// import cats.syntax.arrow._
import escalator.util._

object GeneratorTemplates {
	import TextUtil._

	//TODO
	// id a deleted_at column exists then only do a soft delete by default
	// assumes 0L is id
	// assume rails format. ID SERIAL. CREATED_AT, UPDATED_AT.

	def autoGeneratedCommentTracker() = {
		"// THIS FILE IS AUTO-GENERATED. REMOVE THIS LINE TO STOP THIS FILE BEING RE-GENERATED"
	}

	def autoGeneratedCommentTime() = {
		s"// GENERATED AT: ${TimeUtil.nowString}"
	}

	def autoGeneratedComment() = {
		s"""
		|${autoGeneratedCommentTracker}
		|${autoGeneratedCommentTime}
		""".stripMargin
	}

	def genericDatabaseTemplate(packageSpace: String, appName: String, tableCaseClasses: List[String]) = {

		val tables = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	def ${objectName}: ${tableName}Table"
		}

		s"""
		package ${packageSpace}.persistence

		${autoGeneratedComment}

		import ${packageSpace}.persistence.database.tables._

		trait ${appName}Database {
			${tables.mkString("\n")}
		}
		"""
	}

	def postgresDatabaseTemplate(packageSpace: String, appName: String, tableCaseClasses: List[String]) = {
		val tables = tableCaseClasses.map { tcc =>
			val tableName = pluralize(tcc)
			val objectName = snakeToLowerCamel(snakeify(tableName))

			s"	object ${objectName} extends Postgres${tableName}Table(this) with PostgresCustomEncoder"
		}

		s"""
		package ${packageSpace}.persistence.postgres

		${autoGeneratedComment}

		import io.getquill._
		import escalator.util.logging.Logger

		import escalator.util.monitoring.Monitoring

		import monix.execution.Scheduler
		import ${packageSpace}.persistence.${appName}Database

		import escalator.util.postgres.PostgresDatabase
		import escalator.util.postgres.PostgresDatabase.PostgresDatabaseConfiguration
		import escalator.util.postgres.CustomNamingStrategy

		import ${packageSpace}.common.persistence.postgres.PostgresCustomEncoder
		import ${packageSpace}.common.persistence.postgres.PostgresMappedEncoder

		import ${packageSpace}.persistence.postgres.tables._

		class Postgres${appName}Database(
		  config: PostgresDatabaseConfiguration
		)(implicit
		  logger: Logger,
		  monitoring: Monitoring//,
		) extends PostgresDatabase (
		  new PostgresMonixJdbcContext(CustomNamingStrategy ,"postgres")
		) with ${appName}Database {

		  ///
		  ${tables.mkString("\n")}

		}

		"""
	}

	def canAddUpdateById(table: Table): Boolean = {
		// "StreamingSessions"
		// println("canAddUpdateById table.name:" + table.name)
		// (table.name == "streaming_sessions")
		// (table.name == "candles")
		true
	}

	def tableTraitTemplate(table: Table, packageSpace: String, modelClass: String, tableName: String, tableClass: String) = {
		val initial = modelClass.take(1).toLowerCase
		val primaryKeyClass: Option[String] = table.primaryKeyClass		//s"${modelClass}Id"

		val includeUpsert = table.hasUniqueKeysExcludingPrimaryKey()

		val upsert = DefnBuilder.buildUpsertsDefn(table, packageSpace, modelClass, tableName, tableClass)

		val uniqueChecks = DefnBuilder.buildUniqueCheckDefn(table, packageSpace, modelClass, tableName, tableClass)

		val updatesById = if (canAddUpdateById(table)) {
			DefnBuilder.buildUpdatesByIdDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val updatesByUniqueKeys = if (canAddUpdateById(table)) {
			DefnBuilder.buildUpdatesByUniqueKeysDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val gettersByUniqueKeys = if (canAddUpdateById(table)) {
			DefnBuilder.buildGettersByUniqueKeysDefn(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		// val store = DefnBuilder.buildStoreDefn(table, packageSpace, modelClass, tableName, tableClass)

		val primaryIdFuncs = if (primaryKeyClass.isEmpty){
			""
		} else {
			s"""
				def getById(${initial}: ${primaryKeyClass.get}): Future[Option[${modelClass}]]

				def update(${initial}: ${modelClass}): Future[_]

				def upsert(${initial}: ${modelClass}): Future[${modelClass}]

				def upsert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]]				

				def delete(${initial}: ${modelClass}): Future[_]
			"""
		}

		s"""
		package ${packageSpace}.persistence.database.tables

		${autoGeneratedComment}

		import scala.concurrent.Future

		import ${packageSpace}.models._

		trait ${tableClass} {
		  def tableName = "${table.name.toLowerCase}"

		  //def store(${initial}: ${modelClass}): Future[${modelClass}]

		  //def store(${initial}l: List[${modelClass}]): Future[List[${modelClass}]]

		  //def insert(${initial}: ${modelClass}): Future[_]

		  ${upsert}

		  ${uniqueChecks}

		  ${updatesById}

		  ${updatesByUniqueKeys}

		  ${primaryIdFuncs}

		  ${gettersByUniqueKeys}

		  def count: Future[Long]
		  
		  def getAll(): Future[List[${modelClass}]]
		}
		"""
	}

	def tableDaoTemplate(customGen: CustomGenerator, table: Table, packageSpace: String, modelClass: String, tableName: String, tableClass: String) = {
		// val package = ""
		val initial = modelClass.take(1).toLowerCase
		val primaryKeyClass: Option[String] = table.primaryKeyClass //s"${modelClass}Id"

		println("tableDaoTemplate:" + tableName)
		println(table.uniqueKeysExcludingPrimaryKey)

    	val upsert = CodeBuilder.buildUpsertsCode(table, packageSpace, modelClass, tableName, tableClass)

    	val uniqueChecks = CodeBuilder.buildUniqueCheckDefn(table, packageSpace, modelClass, tableName, tableClass)

		val updatesById = if (canAddUpdateById(table)) {
			CodeBuilder.buildUpdatesByIdCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val updatesByUniqueKeys = if (canAddUpdateById(table)) {
			CodeBuilder.buildUpdatesByUniqueKeysCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

		val gettersByUniqueKeys = if (canAddUpdateById(table)) {
			CodeBuilder.buildGettersByUniqueKeysCode(table, packageSpace, modelClass, tableName, tableClass)
		} else {
			""
		}

    // val store = CodeBuilder.buildStoreCode(table, packageSpace, modelClass, tableName, tableClass)	
    
		val returnClass = if (primaryKeyClass.isEmpty){
			"Long"
		} else {
			primaryKeyClass.get
		}

		val returningValues = if (primaryKeyClass.isEmpty){
			""
		} else {
			".returning(_.id)"
		}    	

		val updateTimeTracking = if (!table.hasColumn("updated_at")){
			""
		} else {
			".copy(updatedAt = ts)"
		}    	

		// defaultConstructorValue()

		val primaryKeyCol = table.primaryKeyCol

		val defaultPrimaryValue = if (primaryKeyCol.isEmpty){
			""
		} else {
			val pc = primaryKeyCol.get
		    if (pc.scalaType == "java.util.UUID") {
		      "escalator.util.RichUUID.BLANK_UUID"
		    } else {
		      "0L"
		    }
		}
		

		val primaryIdFuncs = if (primaryKeyClass.isEmpty){
			""
		} else {

			s"""
			  override def getById(${initial}: ${primaryKeyClass.get}): Future[Option[${modelClass}]] = monitored("getById") {
	            ctx.run(
	                query[${modelClass}]
	                  .filter(_.id == lift(${initial}))
	                  .take(1)
	            ).runToFuture.map(_.headOption)
			  }

			  override def update(${initial}: ${modelClass}): Future[${returnClass}] = monitored("update") {
			  	if (${initial}.id == ${primaryKeyClass.get}(${defaultPrimaryValue})) {
			  		insert(${initial})
			  	} else {
			  		val ts = TimeUtil.nowTimestamp()
			  		ctx.run(
			  			query[${modelClass}]
			  				.filter(_.id == lift(${initial}.id))
			  				.update(lift(${initial}${updateTimeTracking} ))
			  				${returningValues}
			  		).runToFuture
			  	}
			  }

			  override def upsert(${initial}: ${modelClass}): Future[${modelClass}] = {
			  	if (${initial}.id == ${primaryKeyClass.get}(${defaultPrimaryValue})) {
			  		store(${initial})
			  	} else {
			  		val ts = TimeUtil.nowTimestamp()
			  		ctx.run(
			  			query[${modelClass}]
			  				.filter(_.id == lift(${initial}.id))
			  				.update(lift(${initial}${updateTimeTracking} ))
			  				${returningValues}
			  		).runToFuture.map { updatedId =>
				    	${initial}${updateTimeTracking}
				    }
			  	}
			  }		  

			  override def upsert(${initial}l: List[${modelClass}]): Future[List[${modelClass}]] = {
			  	Future.sequence(  ${initial}l.map { ${initial} => upsert(${initial}) }  )
			  }	

			  override def delete(${initial}: ${modelClass}): Future[${returnClass}] = monitored("delete") {
			    ctx.run(
			      query[${modelClass}]
			      	.filter(_.id == lift(${initial}.id))
			        .delete
			        ${returningValues}
			    ).runToFuture
			  }

			"""
		}


		val returningGeneratedValues = if (primaryKeyClass.isEmpty){
			""
		} else {
			".returningGenerated(_.id)"
		}    			

		val storeClassUpdate = if (primaryKeyClass.isEmpty){
			s""".map{ rowCnt =>
		    	toInsert
		    }
		    """			
		} else {
			s""".map{ newId =>
		    	toInsert.copy(id = newId)
		    }
		    """			
		}

		val insertUpdateTimeTracking = if (!table.hasColumn("created_at")){
			""
		} else {
			".copy(createdAt = ts, updatedAt = ts)"
		}

		s"""
		package ${packageSpace}.persistence.postgres.tables

		${autoGeneratedComment}

		import scala.concurrent.Future

		import escalator.util.TimeUtil
		import escalator.util.logging.Logger
		import escalator.util.monitoring.Monitoring

		import escalator.util.postgres.MonitoredPostgresOperation
		import escalator.util.postgres.PostgresDatabase
		import escalator.util.postgres.PostgresDatabase.PostgresDatabaseConfiguration
		import escalator.util.postgres.CustomNamingStrategy

		import ${packageSpace}.common.persistence.postgres.PostgresCustomEncoder
		import ${packageSpace}.common.persistence.postgres.PostgresMappedEncoder

		import ${packageSpace}.models._

		import ${packageSpace}.persistence.database.tables.${tableClass}

		abstract class Postgres${tableClass}(database: PostgresDatabase)
		  (implicit logger: Logger, 
		    monitoring: Monitoring)
		    extends ${tableClass}
		    with PostgresCustomEncoder
		    {

		  def db:PostgresDatabase = database 

		  import PostgresMappedEncoder._

		  import monix.execution.Scheduler.Implicits.global
		  import ctx._

		  ${customGen.customMappers(tableClass)}

		  def monitored(name: String) = MonitoredPostgresOperation(name, tableName)

		  private def store(${initial}: ${modelClass}): Future[${modelClass}] = monitored("store") {
		  	val ts = TimeUtil.nowTimestamp()
		  	
		  	val toInsert = ${initial}${insertUpdateTimeTracking}

		    ctx.run(
		      query[${modelClass}]
		        .insert(lift(toInsert))
		        ${returningGeneratedValues}
		    ).runToFuture${storeClassUpdate}
		  }

		  private def store(${initial}l: List[${modelClass}]): Future[List[${modelClass}]] = monitored("store") {
		  	Future.sequence(  ${initial}l.map { ${initial} => store(${initial}) }  )
		  }

		  private def insert(${initial}: ${modelClass}): Future[${returnClass}] = monitored("insert") {
		  	val ts = TimeUtil.nowTimestamp()
		    ctx.run(
		      query[${modelClass}]
		        .insert(lift(${initial}${insertUpdateTimeTracking}))
		        ${returningValues}
		    ).runToFuture
		  }	  

		  ${upsert}

		  ${uniqueChecks}

		  ${updatesById}

		  ${updatesByUniqueKeys}

		  ${primaryIdFuncs}

		  ${gettersByUniqueKeys}

		  override def count: Future[Long] = monitored("count") {
		    ctx.run(query[${modelClass}].size).runToFuture
		  }

		  override def getAll(): Future[List[${modelClass}]] = monitored("get_all") { 
            ctx.run(
                query[${modelClass}]
            ).runToFuture
		  }		  

		}
		"""	
	}


}